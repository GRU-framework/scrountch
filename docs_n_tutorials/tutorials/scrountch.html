<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>Scrountch</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Scrountch</h1>
<span id="author">Bernard AMADE</span><br />
</div>
<div id="content">
<div class="sect1">
<h2 id="_scrountch_une_librairie_graphique_pour_débutants">Scrountch: une librairie graphique pour débutants</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>scrountch</code> est une bibliothèque de codes graphiques liée au langage <code>Groovy</code> .</p></div>
<div class="paragraph"><p>Ces codes donnent un accès simplifié à des fonctionnalités d&#8217;ordre graphique destinées à l&#8217;apprentissage
de la programmation. Le langage recommandé pour utiliser cette bibliothèque est un sous-ensemble de Groovy.</p></div>
<div class="paragraph"><p>La description de cette version simplifiée du langage <code>Groovy</code>  se trouve dans le livre: "introduction à la programmation informatique: principes et enjeux".</p></div>
<div class="paragraph"><p>Même s&#8217;il s&#8217;agit d&#8217;un outil dont l&#8217;objectif est d&#8217;abord de sensibiliser à la programmation
on notera que la pratique approfondie de <code>scrountch</code> demande de la concentration et donc se situe un peu au-dessus des utilitaires
purement réservés aux novices (genre <code>Scratch</code>).
On peut donc, dans un premier temps, réaliser des exercices simples (tels qu&#8217;ils sont décrits dans l&#8217;ouvrage de référence): ce niveau
de <code>scrountch</code> convient à tous les débutants. Ceux qui commencent à se sentir à l&#8217;aise peuvent ensuite passer à des niveaux
plus complexes dont les détails sont donnés dans cette notice. On a donc ici un outil avec deux niveaux possibles de prise en main.</p></div>
<div class="paragraph"><p>Une caractéristique remarquable de <code>scrountch</code> est que ses codes  sont automatiquement traduits dans la langue de l&#8217;utilisateur.
Les codes d&#8217;origines ont des noms Anglais mais un dictionnaire permet leur traduction: le programmeur débutant
n&#8217;a donc que très peu de mots anglais à retenir pour programmer et peut se concentrer sur la logique de son code.</p></div>
<div class="paragraph"><p>Les quelques mots anglais restants concernent la structuration des codes (<code>if</code>, <code>while</code>, ..) et les types fondamentaux
(<code>int</code>, <code>double</code>, <code>String</code> ,&#8230;) - C&#8217;est donc peu de choses à retenir -</p></div>
<div class="paragraph"><p>Dans certains cas (messages d&#8217;erreur) il se peut que les noms sous-jacents  des codes apparaissent. Pour cette raison
ce petit manuel donne à chaque fois les deux noms du code: le nom en Fançais traduit et le nom "réel" .</p></div>
<div class="paragraph"><p>La présentation de cette librairie est progressive: les mêmes fonctionnalités sont présentées plusieurs fois avec des difficultés progressives.
A la fin un programmeur expérimenté pourra se mettre à la programmation orientée objet et enrichir les codes
en se servant des codes graphiques des bibliothèques <code>java.awt</code> (qui servent de base aux codes de <code>scrountch</code>)</p></div>
<div class="sect2">
<h3 id="_installation">Installation</h3>
<div class="paragraph"><p>Au lieu d&#8217;utiliser la <code>groovyconsole</code> on utilisera un code dérivé nommé <code>scrountchconsole</code>.</p></div>
<div class="paragraph"><p>Pour déployer cet outil vous devez disposer d&#8217;un fichier nommé <code>scrountchConsole.jar</code>: double-cliquez dessus et vous disposez d&#8217;une console pour saisir vos codes
et les exécuter.</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/scrountchConsole.png" alt="console" />
</span></p></div>
<div class="paragraph"><p>Ensuite pour des pratiques plus avancés il conviendra d&#8217;installer <code>Groovy</code> , de positionner la variable d&#8217;environnement <code>GROOVY_HOME</code> ,
et d&#8217;utiliser en ressources de fichier <code>scrountch.jar</code>
(ce fichier jar n&#8217;est pas exécutable et ne contient pas groovy - comme <code>scrountchConsole.jar</code> -). Cette organisation permet alors
de générer de petites applications autonomes qui peuvent être lancées en dehors de la console.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>Les textes que vous tapez sans cette console peuvent être exécutés. Quelques commandes à connaître (les menus ne sont pas encore traduits: toutes nos excuses):</p></div>
<div class="ulist"><ul>
<li>
<p>
&lt;CMD&gt;R : exécute le texte tapé dans la Console. Les résultats s&#8217;affichent dans une sous-fenêtre des résultats.
</p>
</li>
<li>
<p>
&lt;CMD&gt;W : nettoyage de la sous-fenêtre des résultats
</p>
</li>
<li>
<p>
&lt;CMD&gt;S: sauvegarde du script. Notre conseil: créer un répertoire particulier (par exemple de nom <code>src</code>) pour conserver les sources de script et mettre les fichiers
de script dans ce répertoire. Créer des fichiers avec des noms se terminant  en "<code>.scrountch</code>" (ou "<code>.groovy</code>")
</p>
</li>
<li>
<p>
&lt;CMD&gt;O: permet de charger un fichier de script existant.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Pour les utilisateurs avancés nous conseillons la création d&#8217;un répertoire <code>bin</code> pour abriter des binaires générés par compilation.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_prise_de_contact_les_fenêtres_et_les_contextes_graphiques">Prise de contact: les fenêtres et les contextes graphiques</h3>
<div class="sect3">
<h4 id="_une_fenêtre_graphique_le_cadre">Une fenêtre graphique: le Cadre</h4>
<div class="paragraph"><p>Les fonctions principales de la bibliothèque de codes <code>scrountch</code> étant de nature graphique notre premier objectif sera
de générer une fenêtre nous permettant de dessiner.</p></div>
<div class="paragraph"><p>En voici un exemple (avec la charte graphique des fenêtres Mac: si vous êtes sur un autre système la fenêtre apparaitra avec une autre charte graphique)</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/cadreScrounch.png" alt="image cadre" />
</span></p></div>
<div class="paragraph"><p>Sur la console le code à exécuter:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Cadre cadre = créerCadre("ICI scrountch", 200,200)</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>L&#8217;exécution affiche sur la console une trace de l&#8217;objet créé:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Result: scrountch.geom.SFrame[frame1,0,23,200x242,layout=java.awt.BorderLayout,title=ICI scrountch,maximized]</code></pre>
</div></div>
<div class="paragraph"><p>Cette trace donne les caractéristiques réelles de l&#8217;objet créé (par exemple le type réél est <code>scrountch.geom.SFrame</code>)
mais à partir de maintenant on ne se préoccupera pas de ce type de trace.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Ce qui nous intéresse est le résultat concret de l&#8217;exécution: l&#8217;apparition d&#8217;une fenêtre sur l'écran.</p></div>
<div class="paragraph"><p>On a un objet de type <code>Cadre</code> (traduction du nom réel <code>SFrame</code>).</p></div>
<div class="paragraph"><p>Cette fenêtre a un titre (ici "<em>ICI scrountch</em>") et une certaine dimension (nota: on ne peut pas retailler cette fenêtre).
Quand on cliquera sur l&#8217;icone de fermeture de la fenêtre dans le bandeau la fenêtre disparaitra et, au bout d&#8217;un petit laps de temps, le programme s&#8217;arrétera.</p></div>
<div class="paragraph"><p>Dans la fenêtre elle-même on trouvera deux petites bandes gris-foncé (leur rôle sera précisé plus tard) et, au centre un panneau avec un fond clair.
Ce panneau sera l&#8217;espace dans lequel les programmes vont dessiner.</p></div>
</div>
<div class="sect3">
<h4 id="_l_8217_espace_de_dessin_le_canevas">L&#8217;espace de dessin: le Canevas</h4>
<div class="paragraph"><p>Le panneau central d&#8217;un <code>Cadre</code> est le <code>canevas</code> dans lequel on va dessiner.</p></div>
<div class="paragraph"><p>Ses dimensions s&#8217;expriment en <strong>Points</strong> graphiques. Dans toute la suite de ce document toutes les dimensions seront exprimées en  points.</p></div>
<div class="paragraph"><p>Dans l&#8217;exemple précédent on avait  un <code>Canevas</code> (nom réel: <code>Cell</code>) de taille 200x200 points.</p></div>
<div class="paragraph"><p>Donc notre appel de <code>créerCadre("ICI scrountch", 200,200)</code> signifie une demande de création d&#8217;un <code>Cadre</code> avec un bandeau qui affiche "<em>ICI scrountch</em>" et qui
contient un canevas de 200 points de large par 200 points de haut (la largeur est le deuxième argument ,et la hauteur le troisième).</p></div>
<div class="paragraph"><p>On peut obtenir ce <code>Canevas</code> par ce code :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Cadre cadre = créerCadre("ICI scrountch", 200,200)
Canevas fondDessin = cadre.canevas()</code></pre>
</div></div>
<div class="paragraph"><p>Ici la deuxième ligne du code veut dire à peu près ceci: "on a un cadre et on lui demande de nous donner <strong>son</strong> canevas"
<code>cadre.canevas()</code>.  (Effectivement: si on avait créé deux cadres, chacun a un canevas, et alors il faudrait faire <code>Canevas autreDessin = cadre2.canevas()</code>
pour obtenir le contenu du <code>Cadre</code> que nous aurions nommé <code>cadre2</code>)</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>L&#8217;exécution affiche sur la console une trace de l&#8217;objet créé:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Result: scrountch.geom.Cell[canvas0,0,0,200x200]</code></pre>
</div></div>
<div class="paragraph"><p>(Nous ne reviendrons plus sur ces traces)</p></div>
</td>
</tr></table>
</div>
<div class="sidebarblock" id="exoFunc_lab">
<div class="content">
<div class="title">Exercice: fonction simple</div>
<div class="paragraph"><p>Ecrire une fonction : <code>Cadre cadreCarré(String chaineNumérique)</code></p></div>
<div class="paragraph"><p>Le type <code>String</code> désigne une chaîne de caractère (comme <code>"bonjour"</code>)</p></div>
<div class="paragraph"><p>Cette fonction crée un cadre carré (largeur et hauteur sont les mêmes).
L&#8217;appel de cette fonction pourrait se faire de la manière suivante : <code>créerCadre("300")</code>.</p></div>
<div class="paragraph"><p>La raison pour laquelle nous avons choisi un paramètre chaîne au lieux d&#8217;un paramètre entier (qui aurait été <code>créerCadre(300)</code>) est
que l&#8217;on va permettre à l&#8217;utilisateur de saisir la dimension demandée. Cette requête se fait par le code:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>String saisie = readln("veuillez saisir la dimension du Cadre")</code></pre>
</div></div>
<div class="paragraph"><p>Il restera à transformer cette chaîne en un nombre. Ce qui se fait par :</p></div>
<div class="literalblock">
<div class="content">
<pre><code>int dimension = Integer.parseInt(chaineNumérique).</code></pre>
</div></div>
<div class="paragraph"><p><a href="#exoFunc">Lien vers proposition corrigé: </a></p></div>
</div></div>
<div class="paragraph"><p>Un <code>Canevas</code> sert à dessiner des objets graphiques (c&#8217;est d&#8217;ailleurs le nom d&#8217;un type: <code>ObjetGraphique</code> -nom réel <code>GraphicObject</code>-).
On va disposer des objets graphiques dans le canevas et il va les dessiner.</p></div>
<div class="paragraph"><p>Commençons par un objet graphique qui contienne une image. Voici un code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ImageGraphique image  = imageDepuisURL("file:scrountchIcon.png");</code></pre>
</div></div>
<div class="paragraph"><p>On peut ainsi charger une image au travers du Web (trouvez une image avec une adresse <code>http://&#8230;.</code> mais pas avec <code>https:&#8230;</code>)</p></div>
<div class="paragraph"><p>Et maintenant un programme complet qui dispose cette image dans le <code>Canevas</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Cadre cadre = créerCadre("scrountch Image", 200,200)
Canevas fondDessin = cadre.canevas()
ImageGraphique image  = imageDepuisURL("file:scrountchIcon.png")
fondDessin.ajoutGraphique(image)</code></pre>
</div></div>
<div class="paragraph"><p>Si on dispose de l&#8217;image dans le répertoire courant on obtient alors une fenêtre qui affiche cette image:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/CadreScrIcon.png" alt="écran avec image" />
</span></p></div>
<div class="sidebarblock" id="exoImage1_lab">
<div class="content">
<div class="title">Exercice: mise en place d&#8217;une image graphique</div>
<div class="paragraph"><p>Dans le code précédent il y a un risque d&#8217;inadaptation entre la taille de la fenêtre <code>Cadre</code>
et la taille de l&#8217;image à afficher.</p></div>
<div class="paragraph"><p>Or une fois qu&#8217;on a créé une <code>ImageGraphique</code> on peut connaître sa taille:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int largeur = image.largeurInitiale()
int hauteur = image.hauteurInitiale()</code></pre>
</div></div>
<div class="paragraph"><p>(la raison pour laquelle on a quelque chose comme "largeurInitiale" est qu&#8217;on pourra ensuite déformer cette image).</p></div>
<div class="paragraph"><p>Donc en exercice:</p></div>
<div class="ulist"><ul>
<li>
<p>
écrire une fonction <code>afficherImage(String chaîneURL)</code> qui:
</p>
<div class="ulist"><ul>
<li>
<p>
charge une image graphique depuis la <code>chaîne URL</code>
</p>
</li>
<li>
<p>
crée un cadre aux dimensions de l&#8217;image
</p>
</li>
<li>
<p>
affiche  l&#8217;image graphique dans le canevas
</p>
</li>
</ul></div>
</li>
<li>
<p>
pour tester utiliser la fonction <code>readln(String invite)</code> par exemple en codant : <code> String nomURL = readln("taper une URL")</code>.
Puis invoquer la fonction <code>afficherImage</code> avec le résultat.
</p>
</li>
</ul></div>
<div class="paragraph"><p><a href="#exoImage1">Lien vers proposition corrigé: </a></p></div>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_canevas_et_objets_graphiques">Canevas et objets graphiques</h3>
<div class="sect3">
<h4 id="_système_de_positionnement">Système de positionnement</h4>
<div class="paragraph"><p>Dans un <code>Canevas</code> on dispose des objets graphiques en les positionnant à des coordonées exprimées en points.</p></div>
<div class="paragraph"><p>L&#8217;origine des coordonnées (point 0,0) se situe dans le coin supérieur gauche. Et l&#8217;axe des <code>y</code> se dirige vers le bas</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/canvasXY.png" alt="coordonnées dans Canevas" />
</span></p></div>
<div class="paragraph"><p>Dans l&#8217;exemple précédent l&#8217;image était automatiquement disposée au centre.
Mais on peut aussi créer une image graphique avec un ancrage particulier.</p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// imageDepuisFichier charge un fichier sans passer par une URL</i>
<i>// Ici l'image est au centre</i>
 ImageGraphique fond = imageDepuisFichier("marguerites.png")
<i>// Ici l'image sera en coordonnées 100 100</i>
 ImageGraphique duke = imageDepuisFichier("duke2.gif", 100,100)
 Cadre cadre = créerCadre(fond.largeurInitiale(), fond.hauteurInitiale())
 Canevas dessin = cadre.canevas()
<i>// l'ordre dans lequel on ajoute les graphiques</i>
<i>// sera l'ordre dans lequel le dessin s'opérera</i>
 dessin.ajoutGraphique(fond)
 dessin.ajoutGraphique(duke)</code></pre>
</div></div>
<div class="paragraph"><p>Le résultat de l&#8217;exécution:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/dukeFleurs.png" alt="coordonnées dans Canevas" />
</span></p></div>
<div class="paragraph"><p>(remarque: ici l&#8217;image de "duke" -mascotte des programmeurs Java- est rectangulaire mais son fond est transparent, donc on ne voit pas
le rectangle englobant l&#8217;image et on voit le fond en transparence)</p></div>
</div>
<div class="sect3">
<h4 id="_formes_graphiques">Formes graphiques</h4>
<div class="paragraph"><p>Dans un <code>Canevas</code> on peut aussi dessiner des formes géométriques comme des rectangles, des cercles, etc.</p></div>
<div class="paragraph"><p>Pour ce faire on va créer des données de type <code>FormeGraphique</code> (nom réél: <code>GraphicShape</code>).</p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int coorX = 10
int coorY = 20
int largeur = 75
int hauteur = 25
FormeGraphique unRectangle = créerRectangleGraphique(coorX, coorY, largeur, hauteur)</code></pre>
</div></div>
<div class="paragraph"><p>Ce qui après disposition donnera:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/unRectangle.png" alt="un Rectangle dessiné" />
</span></p></div>
<div class="paragraph"><p>Une première sélection de Formes Graphiques:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>FormeGraphique uneEllipse = créerEllipseGraphique(coorX, coorY, largeur, hauteur)</code> : ici le arguments donnent les coordonnées et les dimensions du rectangle
englobant l&#8217;ellipse à dessiner (qui peut être un cercle quand les dimensions sont identiques)
</p>
</li>
<li>
<p>
<code>FormeGraphique uneLigne = créerLigneGraphique(coorX, coorY, largeur, hauteur)</code>: ici aussi les arguments concernant le rectangle englobant la ligne
(la ligne est une diagonale  de ce rectangle).
</p>
</li>
</ul></div>
<div class="sidebarblock" id="exoPolygone_lab">
<div class="content">
<div class="title">Exercice: Polygones</div>
<div class="paragraph"><p>Cet exercice concerne l&#8217;utilisation de tableaux.</p></div>
<div class="paragraph"><p>Pour créer un Polygone on a la fonction</p></div>
<div class="literalblock">
<div class="content">
<pre><code>FormeGraphique unPolygone = créerPolygoneGraphique(int[] coordonnéesX, int[] coordonnéesY)</code></pre>
</div></div>
<div class="paragraph"><p>Les tableaux passés en argument doivent être de même taille. Chaque "sommet" <code>N</code> du polygone se trouve en
<code>coordonnéesX[N]</code> et <code>coordonnéesY[N]</code>.</p></div>
<div class="paragraph"><p>Tracer un polygone simple en déclarant des tableaux de valeurs.</p></div>
<div class="paragraph"><p><a href="#exoPolygone">Lien vers proposition corrigé: </a></p></div>
<div class="paragraph"><p>(pour les amateurs: pour faire un polygone -presque- régulier on peut calculer les positions des  sommets
Les caculs en trigonométrie peuvent s&#8217;effectuer avec les fonctions <code>Math.toRadians</code> puis <code>Math.sin</code>, <code>Math.cos</code> (qui prennent des radians en paramètre) <code>Math.sqrt</code> pour racine carrée, <code>Math.hypot</code> pour le calcul de l&#8217;hypothénuse etc.
Attention: ces calculs rendent des valeurs en <code>double</code> .
Autre conseil: attendre les boucles pour faire des codes généraux de génération de polygones réguliers)</p></div>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_image_échelle_introduction_à_l_8217_animation">Image, échelle, introduction à l&#8217;animation</h3>
<div class="paragraph"><p>On peut avoir besoin d&#8217;afficher une image en ne conservant pas ses dimensions d&#8217;origine (mais en conservant ses proportions).
On peut donc appliquer un rapport de réduction (ou d&#8217;aggrandissement) -appelé ici "échelle"-</p></div>
<div class="paragraph"><p>Ce rapport d'échelle peut être spécifié à la création &#8230; mais il peut aussi être changé avant tout affichage!</p></div>
<div class="paragraph"><p>D&#8217;abord la fixation d'échelle à la création de l&#8217;image Graphique. L'échelle s&#8217;exprime comme un pourcentage:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> <i>// image centrée, échelle 100</i>
 ImageGraphique image1 = imageDepuisFichier(nomDuFichier)
 <i>// image en coorX, coorY, échelle 100</i>
 ImageGraphique image2 = imageDepuisFichier(nomDuFichier, coorX, coorY)
 <i>// image centrée, échelle initiale 50%</i>
 ImageGraphique image3 = imageDepuisFichier(nomDuFichier, 50)
 <i>// image en coorX, coorY, échelle initiale 50%</i>
 ImageGraphique image4 = imageDepuisFichier(nomDuFichier, coorX, coorY, 50)</code></pre>
</div></div>
<div class="paragraph"><p>(on remarquera que la même fonction peut exister avec des paramètres différents - on appelle cette propriété <em>surcharge</em>-)</p></div>
<div class="sidebarblock" id="exoIfGraf_lab">
<div class="content">
<div class="title">Exercice: Choix et mise à l'échelle d&#8217;une image</div>
<div class="paragraph"><p>Cet exercice concerne l&#8217;utilisation d&#8217;un branchement de choix (<code>if</code>)</p></div>
<div class="paragraph"><p>écrire un fonction : <code>def adapterImage(String nomURL)</code></p></div>
<div class="paragraph"><p>l&#8217;objectif est de créer un <code>Cadre</code> de taille fixe (avec un <code>Canevas</code> de 300x300 par ex.)
de charger une image de taille quelconque et de la redimensionner pour qu&#8217;elle rentre dans le <code>Canevas</code>.</p></div>
<div class="paragraph"><p>Donc si l&#8217;image est plus petite que le <code>Canevas</code> on la met telle quelle mais si elle est plus grande on la réduit
d&#8217;un facteur adapté.</p></div>
<div class="paragraph"><p><a href="#exoIfGraf">Lien vers proposition corrigé: </a></p></div>
</div></div>
<div class="paragraph"><p>On peut aussi opérer un changement d'échelle en cours d&#8217;exécution:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> ImageGraphique image = imageDepuisFichier(nomDuFichier)
 dessin.ajoutGraphique(image)
 <i>// on attend 500 millièmes de seconde</i>
 pause(500)
 <i>// on demande 80% de l'image</i>
 image.changerEchelle(80)
 <i>// on demande au dessin de se repeindre</i>
 dessin.repeindre()</code></pre>
</div></div>
<div class="sidebarblock" id="exoLoopGraf_lab">
<div class="content">
<div class="title">Exercice : boucles et animation</div>
<div class="paragraph"><p>Cet exercice concerne l&#8217;utilisation de boucles.</p></div>
<div class="paragraph"><p>Créer une fonction <code>def animation(String url) </code>.
L&#8217;objectif va être d&#8217;animer l&#8217;image désignée par l&#8217;URL en la faisant régulièrement rapetisser puis grossir.</p></div>
<div class="paragraph"><p>Calibrer soigneusement le temps de <code>pause</code> en fonction des caractéristiques de votre ordinateur (<code>pause (150)</code> peut être un bon choix).</p></div>
<div class="paragraph"><p>(le choix d&#8217;une image représentant un coeur sera particulièreent adaptée: on verra le coeur "battre")</p></div>
<div class="paragraph"><p><a href="#exoLoopGraf">Lien vers proposition corrigé: </a></p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_retour_sur_les_formes_graphiques_le_cas_de_la_tortue">Retour sur les formes graphiques, le cas de la Tortue</h3>
<div class="paragraph"><p>En réalité les données de type <code>FormeGraphique</code> qui sont créées par des fonctions comme <code>créerRectangleGraphique</code>, <code>créerEllipseGraphique</code> , etc.
sont réalisées en deux phases:</p></div>
<div class="ulist"><ul>
<li>
<p>
on crée d&#8217;abord une "forme de base" comme un rectangle ou une ellipse (ce sont des données standard des codes <code>java.awt</code> )
</p>
</li>
<li>
<p>
on met cette "forme de base" dans une <code>FormeGraphique</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Pourquoi cet  emballage dans <code>FormeGraphique</code>? Parce que ça nous permet de spécifier des éléments supplémentaires pour dessiner ces formes: la nature et l'épaisseur
du trait, la couleur du trait, la nature du remplissage etc. Nous verrons ces détails plus tard.</p></div>
<div class="paragraph"><p>Donc au lieu de programmer <code>créerRectangleGraphique</code> vous auriez pu décomposer le code en deux opérations:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  <i>// le type RectangleD est un rectangle avec des mesures qui s'exprime avec des valeurs double</i>
  RectangleD rectangleDeBase = créerRectangle(largeur, hauteur)
  FormeGraphique rectangleDécoré = créerFormeGraphique(rectangleDeBase,coordX, coordY, autres paramètres de dessin)</code></pre>
</div></div>
<div class="paragraph"><p>Ici on a créé un rectangle de base d&#8217;une largeur et hauteur donné et on l&#8217;a positionné en <code>coordX, coordY</code>.
On aurait pu le positionner par défaut en écrivant: <code>créerFormeGraphique(rectangleDeBase)</code> ici le rectangle aurait été positionné au centre du <code>Canevas</code> &#8230;
Mais il y a un petit mais: nous verrons ultérieurement que la  notion de centre peut être comprise de deux manière différentes quand on gère des <code>FormeGraphiques</code>.</p></div>
<div class="paragraph"><p>Une forme de base intéressante est la <code>Tortue</code>. Le nom de cette donnée est directement dérivé d&#8217;un code appartenant à l&#8217;histoire de la programmation:
la "tortue" du langage <code>Logo</code>.</p></div>
<div class="paragraph"><p>Une "tortue" est un petit animal imaginaire qui se déplace dans l&#8217;espace de dessin en laissant une trace derrière lui.
La programmation d&#8217;un dessin se résume alors à des ordres de déplacement donnés à la "tortue".</p></div>
<div class="paragraph"><p>Initialement quand on crée une "tortue" à un point donné du dessin elle a la "tête" tournée vers l&#8217;axe des X.</p></div>
<div class="paragraph"><p>Donc pour dessiner un rectangle:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Tortue tortue = créerTortue()
tortue.avancer(200)
tortue.tournerADroite(90)
tortue.avancer(100)
tortue.tournerADroite(90)
tortue.avancer(200)
tortue.tournerADroite(90)
tortue.avancer(100)
<i>//FormeGraphique tortueGraphique = créerFormeGraphique(tortue, recentrer(), recentrer())</i>
FormeGraphique tortueGraphique = formeGraphiqueCentrée(tortue)
canevas.ajoutGraphique(tortueGraphique)</code></pre>
</div></div>
<div class="paragraph"><p>On pourrait objecter que c&#8217;est un moyen bien "tortueux" pour créer un rectangle &#8230; mais nous verrons en exercice que la tortue peut s&#8217;avérer très utile pour certains
dessins. De plus la tortue sait <code>tournerAGauche</code>, <code>sauter</code>, ou même avancer avec un chemin courbe; la programmation avec une tortue permet de réaliser
des formes très étonnantes (par exemple des formes en flocon de neige ou des fractales: faire une recherche d&#8217;images "<em>programming shapes with turtle</em>" -notre "tortue" ne pourra
pas réaliser tous ces dessins car elle n&#8217;a pas la possiblité de changer de couleur en  cours de route mais elle sait déjà faire beaucoup-)</p></div>
<div class="paragraph"><p>Autre remarque sur ce code: le positionnement centré conseillé s&#8217;obtient par une méthode de création particulière:
<code>formeGraphiqueCentrée</code>  (on peut aussi le faire en donnant comme position en x, y des appels de la fonction <code>recentrer()</code> )
la raison de cette technique pour la tortue sera expliquée un peu plus loin.</p></div>
<div class="sidebarblock" id="polyTortue_lab">
<div class="content">
<div class="title">Exercice : boucles, tortue</div>
<div class="paragraph"><p>L&#8217;objectif est de créer une fonction: <code>def polygoneParTortue(int rayon, int nbCotés)</code>
qui dessine un polygone régulier avec une tortue. Pour les détails de calcul voir l&#8217;article Wikipedia "Polygone régulier"</p></div>
<div class="paragraph"><p>Pour simplifier les calculs on peu aussi écrire à la place une fonction <code>def polygoneParTortue(int longueurCoté, int nbCotés)</code>
dans ce cas la seule chose à calculer est l&#8217;angle de roation de la tortue chaque fois qu&#8217;elle a avancé de <code>longueurCoté</code>.</p></div>
<div class="paragraph"><p>N&#8217;oubliez pas pour positionner votre tortue d&#8217;utiliser <code>formeGraphiqueCentrée</code> ou <code>recentrer()</code> si vous voulez fixer les coordonnées au centre du <code>Canevas</code></p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/polygoneTortue.png" alt="un polygone régulier dessiné" />
</span></p></div>
<div class="paragraph"><p><a href="#polyTortue">Lien vers proposition corrigé: </a></p></div>
</div></div>
<div class="sect3">
<h4 id="centrage">Le centrage des formes graphiques</h4>
<div class="paragraph"><p>Il s&#8217;agit d&#8217;un détail que vous pouvez sauter en première lecture mais il existe deux façons différentes de centrer une forme graphique.</p></div>
<div class="paragraph"><p>Cela vient du fait que l&#8217;on peut définir des "formes de base" (<code>Shape</code> en anglais) avec des coordonnées d&#8217;origine.</p></div>
<div class="paragraph"><p>Prenons un exemple avec un Rectangle pour commencer:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>RectangleD rectangle = créerRectangle(10,10, 60,40)
FormeGraphique graphique = créerFormeGraphique(rectangle,0,0)
<i>/// ... etc.</i></code></pre>
</div></div>
<div class="paragraph"><p>Donnera à peu près ceci:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/rectangleGauche.png" alt="rectangle en x" />
</span></p></div>
<div class="paragraph"><p>Par rapport aux coordonnées 0,0 le rectangle est décalé de son origine en 10, 10</p></div>
<div class="paragraph"><p>Maintenant si on "centre" par défaut la forme graphique on a ce code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>RectangleD rectangle = créerRectangle(10,10, 60,40)
FormeGraphique graphique = créerFormeGraphique(rectangle)
<i>/// ... etc.</i></code></pre>
</div></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/rectDecalCentre.png" alt="rectangle en x" />
</span></p></div>
<div class="paragraph"><p>Ici le rectangle est décalé de 10,10 par rapport à la position qu&#8217;il occuperait s&#8217;il était au centre!</p></div>
<div class="paragraph"><p>Ce qui veut dire par exemple que si on a ce code :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>RectangleD rectangle = créerRectangle(-10,-10, 60,40)
FormeGraphique graphique = créerFormeGraphique(rectangle)
<i>/// ... etc.</i></code></pre>
</div></div>
<div class="paragraph"><p>On aura:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/rectDecalCentre2.png" alt="rectangle en x" />
</span></p></div>
<div class="paragraph"><p>Donc un décalage négatif par rapport au centre.</p></div>
<div class="paragraph"><p>Maintenant si on réalise ce code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>RectangleD rectangle = créerRectangle(-10,-10, 60,40)
<i>//FormeGraphique graphique = créerFormeGraphique(rectangle, recentrer(), recentrer())</i>
FormeGraphique graphique = formeGraphiqueCentrée(rectangle)
<i>/// ... etc.</i></code></pre>
</div></div>
<div class="paragraph"><p>On aura:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/rectCentre.png" alt="rectangle centré" />
</span></p></div>
<div class="paragraph"><p>Ici le rectangle est recentré. Pourquoi dans ce cas avoir un rectangle avec des coordonnées négatives?
Effectivement ça ne semble pas très logique &#8230;. mais si vous opérez avec une <code>Tortue</code> (ou avec d&#8217;autres formes graphiques)
il est très facile de se retrouver avec des parties du dessin en coordonnées négatives par rapport à l&#8217;origine!</p></div>
<div class="paragraph"><p>Et c&#8217;est pour cette raison qu&#8217;il est plus raisonnable de recentrer la tortue par:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>formeGraphiqueCentrée(tortue)</code></pre>
</div></div>
<div class="paragraph"><p>Ici on force le recentrage d&#8217;une forme  complexe qui peut avoir des points en coordonnées négatives.</p></div>
<div class="paragraph"><p>Autre forme possible de ce centrage avec des indications particulières de position:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>créerFormeGraphique(tortue, recentrer(), recentrer())</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_traces">Traces</h3>
<div class="paragraph"><p>Dès que vos codes deviennent un peu complexe vous pouvez désirer mettre des traces pour "visualiser" le déroulement de votre code.</p></div>
<div class="paragraph"><p>Bien entendu vous pouvez rajouter des <code>println</code> de messages dans vos codes &#8230; et les enlever ensuite.</p></div>
<div class="paragraph"><p>Une meilleur statégie est de mettre en place des traces qui resteront dans votre code et qui seront activées ou désactivées.</p></div>
<div class="paragraph"><p>Quand vous progresserez plus avant en programmation vous apprendrez à vous servir d&#8217;un système de <code>logging</code> mais en attendant <code>scrountch</code>
vous permet de mettre en place des traces simplifiées.</p></div>
<div class="paragraph"><p>Il faut distinguer les codes qui spécifient les messages de trace des codes qui les activent.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>// mise en place d'une trace
trace("hauteur "+ hauteur, "graphique")</code></pre>
</div></div>
<div class="paragraph"><p>Ici la fonction a deux arguments: un message et un "domaine de trace" librement défini par le programmeur (ici <code>"graphique"</code>)</p></div>
<div class="paragraph"><p>Pour permettre à ces traces d&#8217;apparaître il faudra avoir quelque part dans le code:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>activerTraces("graphique")</code></pre>
</div></div>
<div class="paragraph"><p>on peut activer plusieurs domaines:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>activerTraces("graphique", "calculs")</code></pre>
</div></div>
<div class="paragraph"><p>pour tout arréter:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>stopTraces()</code></pre>
</div></div>
<div class="paragraph"><p>Un petit détail technique (specifique à <code>Groovy</code>) : on peut mettre dans une chaîne de message une référence sur une variable avec une syntaxe partciulière:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>double total
...
trace( "montant = $total", "calculs")</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_déplacements_rotations">Déplacements, rotations</h3>
<div class="sect3">
<h4 id="_les_coordonnées_d_8217_ancrage">Les coordonnées d&#8217;ancrage</h4>
<div class="paragraph"><p>Les "objets" de type <code>FormeGraphique</code> ou <code>ImageGraphique</code> sont créés</p></div>
<div class="ulist"><ul>
<li>
<p>
soit avec des coordonnées "d&#8217;ancrage" explicites: <code>créerRectangleGraphique(ancrageX, ancrageY, largeur, hauteur)</code> ; <code>imageDepuisFichier(nomfichier, ancrageX, ancrageY)</code>
</p>
<div class="paragraph"><p>On retrouve le même dispositif pour les <code>ChaineGraphique</code>s:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  ChaineGraphique chaîne = créerChaineGraphique("Bonjour tout le monde!", ancrageX, ancrageY)</code></pre>
</div></div>
</li>
<li>
<p>
soit automatiquement disposées au centre (pour les <code>ImageGraphique</code>s et les <code>ChaineGraphique</code>s et avec des principes particuliers pour les <code>FormesGraphique</code>s
(voir chapitre précédent sur le centrage des formes graphiques)
</p>
<div class="listingblock">
<div class="content">
<pre><code>  <i>//  sera "ancrée" au centre du Canevas</i>
  ChaineGraphique chaîne = créerChaineGraphique("Bonjour tout le monde!")</code></pre>
</div></div>
</li>
</ul></div>
<div class="paragraph"><p>Lors des opérations de dessin au sein d&#8217;un <code>Canevas</code> on pourra décider de modifier l&#8217;emplacement où l&#8217;objet graphique est effectivement tracé.</p></div>
<div class="paragraph"><p>Lorsqu&#8217;un <code>Canevas</code> est "repeint" (par ex. par <code>fondDessin.repeindre()</code>) le système graphique peut "transformer" le dessin de l&#8217;objet graphique.</p></div>
<div class="paragraph"><p>Il peut opérer (dans l&#8217;ordre):</p></div>
<div class="ulist"><ul>
<li>
<p>
une translation
</p>
</li>
<li>
<p>
une déformation
</p>
</li>
<li>
<p>
une rotation
</p>
</li>
</ul></div>
<div class="paragraph"><p>La déformation étant plus compliquée nous n&#8217;en parlerons que dans le chapitre concernant les opérations avancées</p></div>
</div>
<div class="sect3">
<h4 id="_translations">translations</h4>
<div class="paragraph"><p>Sur tous les objets graphiques on peut opérer des translations par l&#8217;invocation de <code>translation(nbPointsEnX, nbPointsEnY)</code>. par exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  <i>// 10 points vers la gauche, 20 points vers le bas</i>
  <i>// on peut utiliser des nombres négatifs</i>
  image.translation(10,20)</code></pre>
</div></div>
<div class="paragraph"><p>Les translations sont cumulatives: si on appelle deux fois <code>image.translation(10,10)</code> le dessin se fera avec une translation de <code>20,20</code>.</p></div>
<div class="paragraph"><p>Pour annuler les translations (et revenir au point d&#8217;ancrage)</p></div>
<div class="listingblock">
<div class="content">
<pre><code>   <i>// en anglais : image.home()</i>
   image.retour()</code></pre>
</div></div>
<div class="paragraph"><p>Pour annuler l&#8217;accumulation des translations (et fixer une nouvelle translation)</p></div>
<div class="listingblock">
<div class="content">
<pre><code>   <i>// réinitialisée pour un déplacement de x et y points</i>
   image.reinitTranslation(x,y)</code></pre>
</div></div>
<div class="sidebarblock" id="exoTranslationGraf_lab">
<div class="content">
<div class="title">Exercice: boucles, animation, translation</div>
<div class="paragraph"><p>Il y a trois façons de réaliser des animations avec <code>Scrountch</code>:</p></div>
<div class="ulist"><ul>
<li>
<p>
disposer une image de type gif animé: le programmeur n&#8217;a pas à prendre en charge l&#8217;animation qui se fait toute seule
</p>
</li>
<li>
<p>
opérer des transformations successives d&#8217;objets graphiques (avec une succession de <code>pause(attente)</code>, transformation, <code>dessin.repeindre()</code>
</p>
</li>
<li>
<p>
programmer des animations à un bas niveau (plus fluide, mais plus compliqué: sera mentionné avec les aspects avancés de la programmation).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Dans cet exercice nous vous proposons de combiner les deux premières:</p></div>
<div class="ulist"><ul>
<li>
<p>
créer une <code>ImageGraphique</code> avec un gif animé
</p>
</li>
<li>
<p>
déplacer réguliérement cette image de manière à lui faire traverser l'écran
</p>
</li>
</ul></div>
<div class="paragraph"><p>Dans le corrigé on verra l&#8217;image ci-dessous avec un dinosaure qui traverse l'écran en "marchant" de gauche à droite:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/marcheDino.png" alt="un dinosaure traverse l'écran" />
</span></p></div>
<div class="paragraph"><p>Pour calculer la position de l&#8217;image il convient de connaître ses dimensions avant de créer l&#8217;objet <code>ImageGraphique</code>.
Pour cela on va décomposer la création de l&#8217;image graphique en deux phases (opération que l&#8217;on avait déjà vue pour les formes graphiques:
on peut créer d&#8217;abord la forme de base puis ensuite la <code>FormeGraphique</code>)</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// l'image de base s'appelle une Icone</i>
<i>// on pourrait la créer aussi à partir d'un URL</i>
Icone icone = iconeDepuisFichier(nomFichier)
int largeur = icone.largeur() ;
int hauteur = icone.hauteur()
<i>// on calcule la position de l'image graphique puis</i>
ImageGraphique marcheur = créerImageGraphique(icone, posInitialeX, posInitialeY)
<i>// maintenant une boucle d'animation</i></code></pre>
</div></div>
<div class="paragraph"><p><a href="#exoTranslationGraf">Lien vers proposition corrigé: </a></p></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_déplacements_sur_un_axe">déplacements sur un axe</h4>
<div class="paragraph"><p>C&#8217;est une autre forme de translation.</p></div>
<div class="paragraph"><p>On fixe une direction (par un angle) et ensuite on opére des déplacements en suivant cette direction.</p></div>
<div class="paragraph"><p>Sur tous les objets graphiques on peut spécifier une "direction".</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// on prend une direction de 45° dans le sens des aiguilles d'une montre</i>
  monObjetGraphique.direction(45)
<i>// même chose mais avec un déplacement initial exprimé en points</i>
  autreObjetGraphique.direction(60, 50)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_rotations">rotations</h4>
<div class="paragraph"><p>Au moment du dessin d&#8217;un objet graphique on peut opérer des rotations une fois que les translations et déformations ont été exécutées.
Il existe deux types de rotations qui sont exclusives l&#8217;une de l&#8217;autre.</p></div>
<div class="ulist"><ul>
<li>
<p>
les rotations autour du centre
</p>
</li>
<li>
<p>
les rotations autour du "coin" supérieur gauche.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Où se trouvent ces points de rotation?</p></div>
<div class="paragraph"><p>En fait tous les objets graphiques ont un <em>rectangle englobant</em> (le plus petit rectangle qui peut englober la figure ou l&#8217;image ou la chaîne).
Une fois l&#8217;objet graphique déplacé (par translation) ou deformé (nous n&#8217;avons pas expliqué comment) le système calcule le rectangle englobant et opére la rotation demandée.</p></div>
<div class="paragraph"><p>Les rotations s&#8217;expriment en degrés dans le sens des aiguilles d&#8217;une montre et sont cumulatives.</p></div>
<div class="paragraph"><p>Prenons un exemple avec des <code>ImageGraphique</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> <i>// image va basculer autour du centre d'un angle de 45°</i>
 <i>// dans le sens des aiguilles d'une montre</i>
 image1.rotationCentrée(45)
 ...
 <i>// ici on accumule: l'image va basculer de 90°</i>
 image1.rotationCentrée(45)
 ...
 <i>// ici l'image ne va plus tourner autour de son axe</i>
 image1.annulerRotations()</code></pre>
</div></div>
<div class="paragraph"><p>De la même manière on peut accumuler des rotation sur le "coin" origine:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> <i>// rotation autour de l'angle supérieur gauche du rectangle englobant</i>
  image2.rotationCoin(-45)</code></pre>
</div></div>
<div class="paragraph"><p><strong>Attention</strong>: quand on commence à accumuler des rotations d&#8217;un type donné c&#8217;est une erreur de demander une rotation d&#8217;un autre type!
(il faut lancer <code>annulerRotations()</code> d&#8217;abord).</p></div>
<div class="paragraph"><p><strong>Attention</strong>: l&#8217;algorithme actuel des rotations centrées souffre d&#8217;une petite anomalie: dans le cadre d&#8217;une animation il peut y avoir un léger
balancement de la position du centre. Ce défaut sera corrigé dans une version ultérieure</p></div>
<div class="sidebarblock" id="exoRotation_lab">
<div class="content">
<div class="title">Exercice: boucles, animation, rotations</div>
<div class="paragraph"><p>Dans cet exercice d&#8217;animation nous allons combiner des translations et des rotations.</p></div>
<div class="paragraph"><p>Chercher un icone  qui représente un marcheur. Ce marcheur va effectuer un looping: il va marcher le long d&#8217;un cercle tout en tournant sur lui-même.
Il retrouvera sa position initiale quand il aura effectué un tour complet.</p></div>
<div class="paragraph"><p>Un instantané de notre "marcheur" (qui vient d&#8217;effectuer un quart de tour):</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/carousel.png" alt="un looping de marcheur" />
</span></p></div>
<div class="paragraph"><p>Attention: avec des gifs animés l&#8217;exécution dépend des caractéristiques de l'écran &#8230;. des écrans avec des performances basses donnent une animation saccadée.</p></div>
<div class="paragraph"><p><a href="#exoRotatoin">Lien vers proposition corrigé: </a></p></div>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_cadres_avec_canevas_multiples_et_bandeaux">Cadres avec canevas multiples et bandeaux</h3>
<div class="paragraph"><p>Jusqu'à présents nous n&#8217;avions considéré que des <code>Cadre</code>s avec un seul <code>Canevas</code>.</p></div>
<div class="paragraph"><p>En fait il est possible de générer des objets <code>Cadre</code> qui contiennent plusieurs Canevas.</p></div>
<div class="paragraph"><p>Un premier exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// on crée 3 canevas de 100x100</i>
Cadre cadre = créerCadre("vecteur de Cadres", 100, 100, 3)
Canevas dessin1 = cadre.canevas(0)
Canevas dessin2 = cadre.canevas(1)
<i>// etc...</i></code></pre>
</div></div>
<div class="paragraph"><p>Les canevas sont numérotés comme dans des tableaux (l&#8217;index commence à zéro).</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/vecteur.png" alt="un vecteur de canevas" />
</span></p></div>
<div class="paragraph"><p>Il est aussi possible de générer des damiers en deux dimensions:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> Cadre cadre2 = créerCadre("damier", 100, 100, 4, 3)
 Canevas dessin0ligne3 = cadre.canevas(3,0)</code></pre>
</div></div>
<div class="paragraph"><p>On a ici un damier de 4 lignes et 3 colonnes de <code>Canevas</code> de 100x100.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Attention</div>
</td>
<td class="content">
<div class="title">Attention</div>
<div class="paragraph"><p>Dans la plupart des codes graphiques les paramètres de position sont dans l&#8217;ordre <strong>X</strong> , <strong>Y</strong>.</p></div>
<div class="paragraph"><p>Dans tout ce qui touche les index tableaux c&#8217;est l&#8217;ordre ligne/colonne qui s&#8217;impose. On a:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>créérCadre(titre, dimx, dimy, nombreLignes, nombreColonnes)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>cadre.canevas(indexLigne, indexColonne)</code></pre>
</div></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Voici donc un damier (avec en supplément des éléments dans les bandeaux)</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/damier.png" alt="un damier de canevas" />
</span></p></div>
<div class="paragraph"><p>Dans l&#8217;image ci-dessus on a aussi ajouté des éléments dans les bandeaux "Nord" (en haut) et "Sud" (en bas).</p></div>
<div class="paragraph"><p>L'élément  qui affiche simplement un message est un <code>Label</code> et le bouton un <code>Bouton</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Label label = créerLabel("un message pour vous")
 Bouton bouton = créerBouton("action","cliquez ICI")
 cadre2.ajouterAuNord(label)
 cadre2.ajouterAuSud(bouton)</code></pre>
</div></div>
<div class="paragraph"><p>Pour retirer des éléments  d&#8217;un bandeau il faut utiliser <code>retirerDuNord</code> ou <code>retirerDuSud</code>.</p></div>
<div class="paragraph"><p>On remarquera que pour créer un bouton il faut deux chaînes: le deuxième argument est ce que va s&#8217;afficher comme invite sur le bouton
et le premier est une identification du bouton. Pouquoi faut-il donner un nom à un bouton? C&#8217;est ce que nous allons voir en parlant
de la gestion des évènements; en d&#8217;autre termes: que se passe-t-il quand on "clique" sur un bouton? (ou quand on "clique" sur un <code>Canevas</code>?).</p></div>
<div class="paragraph"><p>La gestion des "événements" est importante si l&#8217;on veut gérer des jeux (qui se déroulent soit dans un <code>Canevas</code> soit dans plusieurs).</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/jeuVie.png" alt="un damier de jeu" />
</span></p></div>
</div>
<div class="sect2">
<h3 id="_evénements">Evénements</h3>
<div class="paragraph"><p>Un "événement" correspond à une action de l&#8217;utilisateur qui interagit avec l&#8217;interface graphique.</p></div>
<div class="paragraph"><p>Pour simplifier nous allons uniquement nous intéresser aux "clics" de la souris (et pour simplifier encore plus
nous ne regarderons pas si il y a double-clic ou clic-droit/clic-gauche)</p></div>
<div class="paragraph"><p>Prenons d&#8217;abord le "clic" sur un bouton: il est possible d&#8217;associer un comportement à un clic.</p></div>
<div class="paragraph"><p>Ce comportement sera défini dans une fonction et il faudra associer cette fonction au bouton.
Ceci se fait au moyen d&#8217;une spécificité de <code>Groovy</code>: les fonctions anonymes</p></div>
<div class="paragraph"><p>Prenons un exemple de code situé dans un script <code>scrountch</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> boutonTourneur(String nomFichier) {
    ImageGraphique imageGraphique = imageDepuisFichier(nomFichier)
    <i>//  un "truc" qui donne une  approximation de la taille nécessaire</i>
    int dim = 5 + Math.hypot(imageGraphique.hauteurInitiale(), imageGraphique.largeurInitiale())
    Cadre cadre = créerCadre("Rotations 45", dim, dim)
    Canevas canevas = cadre.canevas()
    Bouton bouton = créerBouton("rotation", "Cliquez pour 45°")
    cadre.ajouterAuSud(bouton)
    canevas.ajoutGraphique(imageGraphique)
    bouton.siClic({ <i>// fonction "anonyme": fermeture</i>
        imageGraphique.rotationCentrée(45)
        canevas.repeindre()
    })
}

boutonTourneur("duke0.gif")</code></pre>
</div></div>
<div class="paragraph"><p>On a passé un bloc de code en argument de <code>siClic</code> du bouton.
Ce bloc représente une fonction anonyme; une <code>Fermeture</code> (<code>Closure</code> en Anglais).
Il s&#8217;agit d&#8217;un dispositif de programmation assez avancé qu&#8217;on ne retrouve pas dans tous les langages.
(Ici le terme "fermeture" marque le fait qu&#8217;on a un code qui "emprunte" des variables au code englobant).</p></div>
<div class="paragraph"><p>On aurait pu écrire le code ci-dessus de la manière suivante:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Fermeture fermeture =  {
    <i>// variables empruntées au code englobant</i>
    imageGraphique.rotationCentrée(45)
    canevas.repeindre()
}
bouton.siClic(fermeture)</code></pre>
</div></div>
<div class="paragraph"><p>Chaque fois que le bouton sera "cliqué" le code de la <code>Fermeture</code> sera exécuté.</p></div>
<div class="paragraph"><p>De la même manière on peut invoquer <code>siClic</code> sur un <code>Canevas</code> et on déclenchera une action chaque fois
que l&#8217;on cliquera sur ce canevas.</p></div>
<div class="paragraph"><p>On aimerait toutefois disposer de plus d&#8217;information quand un tel "clic" se produit. Par exemple: à quel endroit?</p></div>
<div class="paragraph"><p>Dans le cas du <code>Canevas</code> on peut fournir à <code>siClic</code> une fonction anonyme avec 3 paramètres.
Ce qui suppose que l&#8217;on sache définir une telle fermeture: il y a une syntaxe particulière:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>canevas.siClic(
 { Canevas cible, int x, int y -&gt;
    <i>// code qui exploite x et y : l'endroit où la souris a cliqué</i>
 })</code></pre>
</div></div>
<div class="paragraph"><p>Donc ici on a une syntaxe spéciale avec:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>{ liste des paramètres -&gt;
  code
}</code></pre>
</div></div>
<div class="paragraph"><p>On remarquera que le premier paramètre est le <code>Canevas</code> sur lequel on a cliqué.
C&#8217;est pratique si la même fermeture est enregistrée sur plusieurs <code>Canevas</code></p></div>
<div class="paragraph"><p>Pour plus de détails voir
<a href="#siClic">La documentation détaillée</a> et, en particulier,  le code qui permet d&#8217;annuler un "Veilleur" de ce type.</p></div>
<div class="paragraph"><p>D&#8217;ailleurs si on a un <code>Cadre</code> qui dispose de plusieurs <code>Canevas</code> il est possible
d&#8217;enregistrer le même code auprès de tous les <code>Canevas</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Fermeture fermeture = { Canevas cible, int x, int y -&gt;
   <i>//code: dans ce cas ces coordonnées s'ajouterons aux coordonnées x, y.</i>
   <i>//Le centrage est particulièrement délicat</i>
}
cadre.siClicSurTous(fermeture)</code></pre>
</div></div>
<div class="paragraph"><p>Note: il est possible d&#8217;avoir sur un bouton un code avec paramètre:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Fermeture fermeture = { String nomBouton -&gt;
  <i>// code</i>
}
bouton1.siClic(fermeture)
bouton2.siClic(fermeture)</code></pre>
</div></div>
<div class="paragraph"><p>C&#8217;est ici que le premier argument de <code>créerBouton</code> (l&#8217;identification) est utilisé.</p></div>
<div class="sidebarblock" id="exoEvent_lab">
<div class="content">
<div class="title">Exercice: fermeture, gestion d'événements</div>
<div class="paragraph"><p>Un grand classique utile pour de nombreux jeux:</p></div>
<div class="ulist"><ul>
<li>
<p>
créer un <code>Cadre</code> en damier (avec Y lignes et X colonnes)
</p>
</li>
<li>
<p>
charger une image représentant un pion (éventuellement faire une réduction d'échelle)
</p>
</li>
<li>
<p>
pour chaque <code>Canevas</code> dans le damier: si on clique on positionne un pion (l&#8217;image d&#8217;un pion) dans le <code>Canevas</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p><a href="#exoEvent">Lien vers proposition corrigé: </a></p></div>
<div class="paragraph"><p>A partir de là on peut réaliser de nombreux codes, avec des pions de différentes couleurs et des règles.</p></div>
<div class="paragraph"><p>Un conseil: faire un "modèle" du jeu, c&#8217;est à dire un tableau qui représente la logique du jeu.</p></div>
<div class="paragraph"><p>Pour faire un tableau à deux dimensions qui représente un "modèle" du damier dans le <code>Cadre</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// un tableau remplis de zéros</i>
int[][] modèle = new int[lignes][colonnes]

<i>//"cellule" à la deuxième ligne, première colonne</i>
int val = modèle[1][0]
<i>// on le fera correspondre à cadre.canevas(1,0)</i></code></pre>
</div></div>
<div class="paragraph"><p>En gérant ce tableau "modèle" on saura ce qu&#8217;il faut mettre dans la cellule correspondante en gérant les règles du jeu
à partir des données contenu dans ce tableau (par exemple: si le joueur noté "1" utilise une cellule le joueur noté "2" ne pourra pas se positionner
dans cette cellule, etc. après chaque "coup" on peut regarder ce que l&#8217;on met dans le <code>canevas</code> correspondant: on peut enlever un objet graphique d&#8217;un <code>Canevas</code>
en invoquant <code>leCanevas.effacerGraphique(objetGraphique)</code> ou <code>leCanevas.effacerTout()</code>)</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_courbes_et_fonctions">Courbes et fonctions</h3>
<div class="paragraph"><p>Puisque maintenant on sait manipuler des fonctions en tant que données (que l&#8217;on peut passer en paramètre)
on peut faire appel à des utilitaires <code>scrountch</code> permettant de dessiner des courbes sur un <code>Canevas</code>.</p></div>
<div class="paragraph"><p>A la base il y a trois façons de dessiner des courbes:</p></div>
<div class="ulist"><ul>
<li>
<p>
point par point
</p>
</li>
<li>
<p>
avec une courbe continue
</p>
</li>
<li>
<p>
avec un histogramme
</p>
</li>
</ul></div>
<div class="paragraph"><p>Voici un exemple de la même courbe réalisée de ces trois manières (dans un des cas on a rajouté des axes):</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/functions.png" alt="scr_images/functions.png" />
</span></p></div>
<div class="paragraph"><p>Un exemple de code :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Forme courbe = courbeParPoints(-3.20,+3.20,-1, +1, 0.1, 100, {double x -&gt; Math.sin(x)})
FormeGraphiqe courbeGraphique = formeGraphiqueCentrée(courbe)</code></pre>
</div></div>
<div class="paragraph"><p>Pour toutes les courbes les arguments sont:</p></div>
<div class="ulist"><ul>
<li>
<p>
la valeur minimum de x (ici <code>-3.20</code>)
</p>
</li>
<li>
<p>
la valeur maximum de x (ici <code>3.20</code>)
</p>
</li>
<li>
<p>
la valeur minimum de y (ici <code>-1</code>). <strong>Point important</strong>: on notera que les Y sont dessinés comme dans les courbes
classiques (les coordonnées "vers le haut" au lieu des coordonnées "vers le bas" utilisées dans les dispositions graphiques)
</p>
</li>
<li>
<p>
la valeur maximum de y (ici <code>1</code>)
</p>
</li>
<li>
<p>
la fréquence de l'échantillonage: c&#8217;est à dire l&#8217;intervalle entre deux calculs de <code>y</code> (ici x est incrémenté de <code>0.1</code> pour chaque calsul de y).
Ici l&#8217;intervalle est régulier mais nous verrons ultérieurement qu&#8217;il est possible de le faire varier (par exemple pour adopter une échelle logarithmique).
</p>
</li>
<li>
<p>
l'échelle d&#8217;affichage (ici <code>100</code> donc les valeurs sont multipliées par 100 pour affichage)
</p>
</li>
<li>
<p>
la fonction  à éxécuter pour chaque calcul (ici <code> {double x &#8594; Math.sin(x)}</code>). Si le résultat du calcul sort des bornes (supérieur au Y maximum ou inférieur au Y minimum)
le point de sera pas dessiné.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Il est vivement conseillé de centrer la forme obtenue (à moins de bien en maitriser les coordonnées).</p></div>
<div class="paragraph"><p>Pour créer une courbe continue:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Forme courbe = courbe(-3.20,+3.20,-1, +1, 0.1, 100, {double x -&gt; Math.sin(x)})</code></pre>
</div></div>
<div class="paragraph"><p>(Attention toutefois: il ne s&#8217;agit pas d&#8217;une vraie courbe continue mais d&#8217;un tracé résultant de la concaténation de petites droites; si l&#8217;intervalle
d'échantillonnage est trop grand on verra apparaître cette succession de droites)</p></div>
<div class="paragraph"><p>Pour un histogramme:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Forme histo = histogramme(-3.20,+3.20,-1, +1, 0.1, 100, {double x -&gt; Math.sin(x)})</code></pre>
</div></div>
<div class="paragraph"><p>(note: on a la possibilité de dessiner des histogrammes très sophistiqués, toutefois ces codes sont réservés à des programmeurs ayant déjà acquis
de l&#8217;expérience)</p></div>
<div class="sect3">
<h4 id="_tracé_des_axes">Tracé des axes</h4>
<div class="paragraph"><p>On peut rajouter des objets graphiques représentant des axes. Il faudra prendre toutefois des précautions de taille et de positionnement pour
que les axes et les courbes aient bien les mêmes origines.</p></div>
<div class="paragraph"><p>On peut créer un jeu d&#8217;axes simples &#8230; mais il est conseillé d&#8217;avoir les même paramètres que les courbes associés:</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>//axes (minX, maxX, minY, maxY, échelle)</i>
Forme axes = axes(-3.20,+3.20,-1, +1,  100)
FormeGraphiqe courbeGraphique = formeGraphiqueCentrée(axes)</code></pre>
</div></div>
<div class="paragraph"><p>Les axes gradués :</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>//axes (minX, maxX, minY, maxY, échelle, intervalle graduation)</i>
Forme axes = axesGradués(-3.20,+3.20,-1, +1,  100, 0.1)</code></pre>
</div></div>
<div class="paragraph"><p>Axes gradués avec des graduations mineures et majeures</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>//axes (minX, maxX, minY, maxY, échelle, intervalle graduation, graduation majeur toutes les N graduations -ici 5-)</i>
Forme axes = axesGradués(-3.20,+3.20,-1, +1,  100, 0.1, 5)</code></pre>
</div></div>
<div class="paragraph"><p>A FAIRE: graduations fonctionnelles (par ex. logarithmiques)</p></div>
</div>
<div class="sect3">
<h4 id="_aspects_avancés">Aspects avancés</h4>
<div class="paragraph"><p><code>EN COURS DE REDACTION</code></p></div>
</div>
</div>
<div class="sect2">
<h3 id="_programmation_à_objets_et_détails_du_dessin">Programmation à objets et détails du dessin</h3>
<div class="paragraph"><p>A partir de maintenant nous allons nous orienter vers un autre style de programmation: la programmaton "à objet".</p></div>
<div class="paragraph"><p>En fait, comme monsieur Jourdain, vous la pratiquiez sans forcément le savoir: quand on écrit</p></div>
<div class="literalblock">
<div class="content">
<pre><code>cadre.canevas()</code></pre>
</div></div>
<div class="paragraph"><p>On demande un <code>canevas</code> à un cadre particulier (on pourrait en demander un à un autre <code>Cadre</code> nommé <code>cadre2</code> et <code>cadre2.canevas()</code> nous donnerait un autre <code>Canevas</code>)</p></div>
<div class="paragraph"><p>Dans ce contexte on dira (et en fait on a déjà dit) que les variables  <code>Cadre cadre</code> et <code>Canvas dessin</code> étaient des "objets"
auxquels on va demander des services. On peut, par exemple, demander à <code>dessin</code> de rajouter un objet graphique en écrivant <code>dessin.ajoutGraphique(imageGraphiqe1)</code></p></div>
<div class="paragraph"><p>Donc petit à petit nous allons utiliser des éléments d&#8217;une librairie graphique de base  qui s&#8217;appelle <code>java.awt</code> (d&#8217;ailleurs <code>scrountch</code> est lui même bâti
sur cette librairie et c&#8217;est pour cela que nous allons petit à petit mélanger les deux types de codes.</p></div>
<div class="sect3">
<h4 id="_couleurs">Couleurs</h4>
<div class="paragraph"><p>Les premières données que nous allons emprunter à <code>java.awt</code>  sont des objets couleur: le nom du type est <code>Color</code> (et oui maintenant nous allons
aussi utiliser des noms anglais au lieu des noms français qui "cachaient" jusqu'à présent les vrais noms des codes)</p></div>
<div class="paragraph"><p>Un premier essai:</p></div>
<div class="listingblock">
<div class="content">
<pre><code><strong>import</strong> java.awt.Color

Cadre cadre = new Cadre("couleur",150,150)
Canevas canevas = cadre.canevas()
canevas.arrièrePlan(Color.YELLOW)
canevas.repeindre()</code></pre>
</div></div>
<div class="paragraph"><p>Ce qui donne à l&#8217;affichage:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/canevasJaune.png" alt="un canevas de couleur" />
</span></p></div>
<div class="paragraph"><p>Dans ce code:</p></div>
<div class="ulist"><ul>
<li>
<p>
On utilise une <em>constante prédéfinie</em> (<code>Color.YELLOW</code>) qui est liée à la classe <code>Color</code>
</p>
</li>
<li>
<p>
pour avoir la possibilité d'écrire <code>Color</code> (nom simplifié de la classe <code>java.awt.Color</code>) on met en début de fichier
une déclaration (ça s&#8217;appelle une <em>directive</em>) qui indique que l&#8217;on va utiliser ce nom simplifié: <code>import java.awt.Color</code>
</p>
</li>
<li>
<p>
on a demandé au <code>canevas</code> d&#8217;avoir une couleur de fond jaune (via l&#8217;invocation de <code>arrièrePlan</code> -<code>setBackGround</code> en Anglais-).
De la même manière  on pourrait doter le <code>Canevas</code> d&#8217;une couleur par défaut pour les tracés:  <code>canevas.couleurTracé(Color.RED)</code> par exemple -le "vrai"
nom est <code>setForeground</code>)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Si la classe <code>java.awt.Color</code> offre quelques couleurs standard il vous est possible de définir votre propre couleur.</p></div>
<div class="paragraph"><p>Exemple: <code>Color doré = new Color(212,175,55)</code></p></div>
<div class="paragraph"><p>Ici:</p></div>
<div class="ulist"><ul>
<li>
<p>
On a créé une couleur (RGB: red/green/blue) par l&#8217;invocation d&#8217;un <em>constructeur</em> : opération <code>new</code>
</p>
</li>
<li>
<p>
Les paramètres sont des entiers entre 0 et 255. Dans l&#8217;ordre:  rouge, vert, bleu. On peut aussi rajouter un facteur de transparence en 4° argument.
Ainsi <code>new Color(0,0,0,0)</code> créera une couleur complètement transparente (255 indiquerait une couleur complètement opaque).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Il est possible de dessiner un objet graphique avec d&#8217;autres couleurs que celles fixées par défaut dans le <code>Canevas</code> support du dessin. Cette couleur peut-êter fixée au moment de la création ou changée en cours de route:</p></div>
<div class="ulist"><ul>
<li>
<p>
Pour une <code>ChaineGraphique</code> on peut la créer au moyen d&#8217;une des "fabriques" (fonction de création) qui prend un paramètre <code>Color</code>.
Par exemple: <code>ChaineGraphique message = créerChaineGraphiqe("Bonjour!", Color.RED)</code>
</p>
<div class="paragraph"><p>On peut aussi changer la couleur après création: <code>message.couleurTracé(Color.BLUE)</code></p></div>
</li>
<li>
<p>
Pour une <code>FormeGraphique</code> tout dépend du mode de création:
</p>
<div class="ulist"><ul>
<li>
<p>
si on veut changer la couleur après création on peut aussi faire: <code>laForme.couleurTracé(Color.GREY)</code>
</p>
</li>
<li>
<p>
pour avoir une couleur de tracé à la création il faut passer par la création en deux étapes!
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code><strong>import</strong> java.awt.Color
<i>// on crée d'abord la forme de base</i>
RectangleD rectangle = créerRectangle(1,1, 40, 50)
<i>// et on l'intègre dans un ensemble complet FormeGraphique</i>
FormeGraphique laForme = créerFormeGraphique(rectangle, Color.BLUE)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_remplissage">Remplissage</h4>
<div class="paragraph"><p>Dans le cas des <code>FormeGraphique</code> il est possible de spécifier un remplissage.</p></div>
<div class="paragraph"><p>Attention toutefois si la "forme de base " n&#8217;est pas fermée (un arc, une tortue qui ne revient pas au point de départ,&#8230;) il
n&#8217;est pas garanti que le remplissage s&#8217;opére selon vos voeux!</p></div>
<div class="paragraph"><p>Ce remplissage peut être une couleur (<code>Color</code>):</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>FormeGraphique laForme = créerFormeGraphique(rectangle, Color.BLUE, COLOR.RED)</code> créera un rectangle bleu rempli de rouge
</p>
</li>
<li>
<p>
<code>laForme.remplissage(Color.RED)</code> remplira la forme graphique du rectangle (après création: on change la couleur de remplissage).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ce remplissage peut être aussi plus sophistiqué en utilisant un objet de type <code>Paint</code> (peinture).
Ici il va vous falloir aller lire la documentation des classes  de <code>java.awt</code>
qui sont des "peintures": <code>GradientPaint, LinearGradientPaint, MultipleGradientPaint, RadialGradientPaint, TexturePaint</code>.
(Ceci vous familiarisera avec le programmation objet et la recherche de documentation).</p></div>
<div class="paragraph"><p>Voici un exemple de ce qui peut être réalisé:</p></div>
<div class="paragraph"><p><span class="image">
<img src="scr_images/balle.png" alt="une balle" />
</span></p></div>
<div class="paragraph"><p>et le code correspondant (utilisant  du code "objet" spécifique à <code>java.awt.RadialGradientPaint</code>)</p></div>
<div class="listingblock">
<div class="content">
<pre><code><strong>import</strong> java.awt.Color
<strong>import</strong> java.awt.RadialGradientPaint
Cadre cadre = créerCadre("balle", 300,300)
Color[] colors = [Color.WHITE, Color.RED]
float[] ratios = [0.0, 1.0]
int dim = 150
int radius = dim/2
RadialGradientPaint paint = new RadialGradientPaint(radius, radius, radius,ratios,colors)
EllipseD ellipse = créerEllipse(dim, dim)
FormeGraphique forme = créerFormeGraphique(ellipse, 10,10 Cell.TRANSPARENT, paint)
Canevas dessin = cadre.canevas()
dessin.ajoutGraphique(forme)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_traits">Traits</h4>
<div class="paragraph"><p>Pour les <code>FormeGraphique</code>s il est possible de changer les caractéristiques du trait (épaisseur, forme des extrémités, tirets,  etc..).</p></div>
<div class="paragraph"><p>Il est tout à fait possible de construire ainsi des "traits" (<code>Stroke</code>) avec des caractéristiques amusantes.
Pour le moment nous nous contenterons de traits de type <code>TraitSimple</code> (nom réel: <code>java.awt.BasicStroke</code>): ce peut être réalisé en utilisant un
des "constructeurs" de la classe ou généré par la fonction "fabrique" <code>créerTrait</code>.</p></div>
<div class="paragraph"><p>Par exemple: <code>créerTrait(4)</code> générera un trait simple de 4 points d'épaisseur.</p></div>
<div class="paragraph"><p>Comme toujours c&#8217;est une caractéristique qui peut être initialisé au moment de la création de la <code>FormeGraphique</code> ou changée en cours de route.</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// on crée d'abord la forme de base</i>
RectangleD rectangle = créerRectangle(40, 50)
<i>// ATTENTION: trait est un mot-clef réservé!</i>
TraitSimple trait3 = créerTrait(3)
<i>// et on l'intègre dans un ensemble complet FormeGraphique</i>
<i>// il est possible de définir des couleurs et un trait</i>
FormeGraphique laForme = créerFormeGraphique(rectangle, trait3)
<i>/// ... un peu plus loin</i>
TraitSimple trait6 = créerTrait(6)
laForme.changerTrait(trait6)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_police_de_caractères">Police de caractères</h4>
<div class="paragraph"><p>Pour gérer l&#8217;affichage des objets de type <code>ChaineGraphique</code> il est possible de changer la police de caractères.
Il y en a une par défaut liée au <code>Canevas</code> mais elle peut-être changée pour chaque objet de type <code>ChaineGraphique</code>.</p></div>
<div class="paragraph"><p>Ici nous allons un peu plus vers l&#8217;utilisation de classes standard et vers une programmation "à objets".</p></div>
<div class="paragraph"><p>La classe qui définit une Police de caractères et la classe <code>java.awt.Font</code>.</p></div>
<div class="paragraph"><p>Voici un exemple de code pour créer une police:</p></div>
<div class="listingblock">
<div class="content">
<pre><code><strong>import</strong> java.awt.Font

Font police = new Font(Font.MONOSPACED,FONT.PLAIN,24)</code></pre>
</div></div>
<div class="paragraph"><p>Les arguments:</p></div>
<div class="ulist"><ul>
<li>
<p>
Le premier argument est le nom d&#8217;une police ce peut être une désignation standard (<code>MONOSPACED, SERIF,SANS_SERIF,DIALOG,DIALOG_INPUT</code>) mais ça
peut être aussi le nom d&#8217;un police spécifique trouvée sur votre système; par ex. "Baskerville" ou "Dingbats"
</p>
</li>
<li>
<p>
Le second argument indique le type de graphie : <code>PLAIN, ITALIC, BOLD, BOLD+ITALIC</code> pour normal, italique, gras, italique gras.
</p>
</li>
<li>
<p>
Le troisième est la taille de la police
</p>
</li>
</ul></div>
<div class="paragraph"><p>Comme toujours c&#8217;est une caractéristique qui peut être initialisé au moment de la création de la <code>ChaineGraphique</code> ou changée en cours de route.</p></div>
<div class="listingblock">
<div class="content">
<pre><code><strong>import</strong> java.awt.Font
Font policeHelvétique = new Font("Helvetica", Font.ITALIC, 18)
ChaineGraphique chaine = créerChaineGraphique("Klaatu Barada Nikto", policeHelvétique)
<i>// plus tard</i>
chaine.changerPolice(autrePolice)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_chaines_graphiques_complexes">Chaines Graphiques complexes</h4>
<div class="paragraph"><p>En fait il existe deux sortes de chaînes graphiques:</p></div>
<div class="ulist"><ul>
<li>
<p>
Celles qui sont réalisées à partir de polices de caractères "natives": on peut fixer éventuellement leur fonte et leur couleur
</p>
</li>
<li>
<p>
Celles qui sont réalisées par dessin: on peut fixer en plus un mode de remplissage et un type de trait
<a href="#chaineGraphique">voir ICI pour plus de détails</a>. On peut ainsi réaliser des affichages spectaculaires.
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_collisions">Collisions</h4>
<div class="paragraph"><p><code>EN ATTENTE</code> (détection d'évènements de collision lors de déplacements d&#8217;objets: le code sous-jacent pose des
problèmes complexes et sa rédaction reste ouverte aux contributeurs "<em>Open source</em>")</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_programmation_à_objet">Programmation à objet</h3>
<div class="paragraph"><p>Si vous êtes arrivé au niveau de la programmation à objet vous pouvez maintenant essayer de codes vos propres classes et les utiliser.</p></div>
<div class="paragraph"><p>Exemple de classe simple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code><i>// ne pas mettre de caractère accentué dans les noms de classe</i>
<strong>class</strong> UneEtoile <strong>extends</strong> Tortue{
   UneEtoile(int nbCotés, int longueurCoté) {
       double anglPolygone = ((nbCotés -2) * 180D)/ nbCotés
       double angleEtoile = (180D /nbCotés)
       <strong>for</strong>(int ix = 0; ix &lt;nbCotés; ix++) {
          avance(longueurCoté)
          tourneGauche(anglPolygone-angleEtoile)
          avance(longueurCoté)
          tourneDroite(180 - angleEtoile)
       }
   }
}</code></pre>
</div></div>
<div class="paragraph"><p>Maintenant sauvegarder ce code dans un fichier de nom <code>UneEtoile.groovy</code></p></div>
<div class="paragraph"><p>Effacer le texte de votre console et maintenant exécutez le code suivant:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>compiler("UneEtoile.groovy")</code></pre>
</div></div>
<div class="paragraph"><p>Si tout se passe bien vous verrez dans votre  répertoire apparaître un fichier nommé <code>UneEtoile.class</code>.</p></div>
<div class="paragraph"><p>Il s&#8217;agit d&#8217;un fichier binaire qui contient le code exécutable de votre classe.</p></div>
<div class="paragraph"><p>Maintenant si vous écrivez un autre script comme:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>UneEtoile étoile = new UneEtoile(13,50)
println étoile.pointCourant()
<i>//FormeGraphique forme = créerFormeGraphique(étoile, recentrer(), recentrer())</i>
FormeGraphique forme = formeGraphiqueCentrée(étoile)
<i>// s'appelle aussi plusGrandeDim (ajout sur Forme/Shape)</i>
int dim = étoile.maxDim() + 5
Cadre cadre = créerCadre("étoile", dim, dim)
Canevas canevas = cadre.canevas()
canevas.ajoutGraphique(forme)</code></pre>
</div></div>
<div class="paragraph"><p>Ce code saura utiliser votre nouvelle classe <code>UneEtoile</code> &#8230;. sauf si &#8230; sauf si le répertoire qui contient votre fichier ".class" n&#8217;est pas
dans votre <code>CLASSPATH</code> (ici ça devient un peu technique: normalement l&#8217;exécuteur cherche des classes dans un ensemble de répertoires
décrits dans la variable d&#8217;environnement <code>CLASSPATH</code> &#8230; voir comment faire sur votre système d&#8217;exploitation)L</p></div>
<div class="sect3">
<h4 id="_autres_aspects_avancés">Autres aspects avancés</h4>
<div class="paragraph"><p><code>EN COURS DE REDACTION</code> (affineTransform, traitement image)</p></div>
<div class="paragraph"><p><code>EN COURS DE REDACTION</code> (BufferedImage pour animation)</p></div>
</div>
<div class="sect3">
<h4 id="_utilisation_de_l_éditeur_graphique_interactif">Utilisation de l'éditeur graphique interactif</h4>
<div class="paragraph"><p><code>EN ATTENTE</code> (comment créer des dessins avec la souris)</p></div>
</div>
<div class="sect3">
<h4 id="_sauvegardes_d_8217_objets">Sauvegardes d&#8217;objets</h4>
<div class="paragraph"><p><code>EN ATTENTE</code> (sauvegardes et lectures d&#8217;objets dans des fichiers - en particulier les dessins créés avec l'éditeur interactif -)</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_création_d_8217_applications_autonomes">Création d&#8217;applications autonomes</h3>
<div class="paragraph"><p><code>EN ATTENTE</code> (réaliser un code autonome qui sera lancé sans passer par la Console)</p></div>
</div>
<div class="sect2">
<h3 id="_sugggestions_d_8217_exercices">Sugggestions d&#8217;exercices</h3>
<div class="paragraph"><p><code>EN COURS DE REDACTION</code> (à faire: billard, jeu de la vie, tic-tac-toe, démineur preneur de décision,..)</p></div>
</div>
<div class="sect2">
<h3 id="_liste_des_classes_et_méthodes">Liste des classes et méthodes</h3>
<div class="paragraph"><p>Chaque désignation en français est suivie du nom original en Anglais qui a été traduit. Dans certains cas il n&#8217;y a pas de traduction en français.</p></div>
<div class="paragraph"><p>Les codes qualifiés de "fonction" sont en fait des méthodes statiques de la class <code>Fab</code>.</p></div>
<div class="sect3">
<h4 id="_utilitaires_généraux">Utilitaires généraux</h4>
<div class="paragraph"><p>Il s&#8217;agit de "fonctions" utilitaires définies dans la classe <code>scrountch.Fab</code> (pour les puristes: ce sont des "méthodes statiques" de la classe)</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>trace(message,domaine)</code>: permet de mettre en place (dans le domaine d&#8217;application) une trace conditionnelle (un <code>message</code>)
</p>
</li>
<li>
<p>
<code>activerTraces(domaines&#8230;)</code> (&#8658; <code>enableTraces(domains&#8230;)</code>) : permet d&#8217;activer les traces dans un ou plusieurs "domaines" passés en paramètres.
</p>
</li>
<li>
<p>
<code>stopTraces()</code>: stoppe toutes traces.
</p>
</li>
<li>
<p>
<code>int nombreAuHasard(int borneSup)</code> ( &#8658; <code>int randomInt(int upperBound)</code>): donne un entier tiré au hasard entre 0 et <code>borneSup</code> (exclus).
</p>
</li>
<li>
<p>
<code>String readln(String invite)</code>: génère depuis la console une fenêtre séparée qui permet d&#8217;afficher <code>invite</code> et saisir une chaîne de caractères. A utiliser uniquement
avec des applications graphiques (y compris la console).
</p>
</li>
<li>
<p>
<code>pause(int delay)</code>: le fil d&#8217;exécuion courant est suspendu pendant <code>delay</code> millisecondes (ici essentiellement utilisé pour les animations).
</p>
</li>
<li>
<p>
<code>int garder()</code> ( &#8658; <code>int keep()</code>): génère une valeur particulière qui permet de créer une forme graphique qui conserve les coordonnées initiales
de la figure contenue. Certaines figures sont définies par elles-même comme ayant des coordonées x, y: quand on crée un objet <code>FormeGraphique</code> on a
la possibilité de préciser les coordonnées de la figure contenue: si on utilise <code>garder()</code> pour désigner une coordonnée on indique alors que l&#8217;on désire
conserver les coordonnées initiale de la figure (et pas passer un paramètre qui changerait ces coordonnées et déplacerait la figure: voir des explications
de ce type
<a href="#centrage">&#8594; ICI</a>).
Donc si on a un rectangle dont les coordonnées de la figure sont initiées en 10,20, si on crée une <code>FormeGraphique</code> en donnant des coordonnées x, y 5,5 le rectangle
sera en 15,25; si on passe en paramètre une invocation de <code>garder()</code> le rectangle sera bien positionné en 10,20).
</p>
</li>
<li>
<p>
<code>int recentrer()</code> (&#8658; <code>int forceCenter()</code>): génère une valeur particulière qui permet de recentrer une figure (qui a ses propres coordonnées internes)
voir les explications
<a href="#centrage">&#8594; ICI</a>. Voir également la  fabrique <code>formeGraphiqueCentrée</code>
</p>
</li>
<li>
<p>
<code>compiler(String[] nomsDeFichier)</code> ( &#8658; <code>compileFiles(String[] fileNames)</code>): permet de compiler un ensemble de fichiers en même temps.
Ces fichiers ont une extension <code>.groovy</code> et contiennent du code  <code>groovy</code> ou <code>scrountch</code> (il est possible de compiler des fichiers
avec extension <code>.scrountch</code> mais c&#8217;est un peu plus compliqué). Si tout se passe bien les fichiers <code>.class</code> correspondant au résultat
de la compilation seront générés.
</p>
</li>
<li>
<p>
<code>compiler(String nomDeFichier)</code> ( &#8658; <code>compileFiles(String fileName)</code>): même code que précédent mais prend en argument un seul nom de fichier
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="cadre">Cadre (&#8658; SFrame)</h4>
<div class="paragraph"><p>Les "fabriques" (fonctions <code>créerCadre</code> - &#8658; <code>createFrame</code> - définies dans <code>Fab</code>) et les constructeurs ont les mêmes paramètres</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>(étiquette, largeurCanevas, hauteurCanevas)</code> : crée un <code>Cadre</code> avec un titre, et contenant un seul <code>Canevas</code> avec une largeur (en points) et une hauteur (en points)
</p>
</li>
<li>
<p>
<code>(largeurCanevas, hauteurCanevas)</code>: même chose mais sans titre.
</p>
</li>
<li>
<p>
<code>(étiquette, largeurCanevas, hauteurCanevas, nombreColonnes)</code>: crée un <code>Cadre</code> avec un titre et avec un alignement de <code>nombreColonnes</code> <code>Canevas</code> avec tous les
mêmes dimensions de largeur et de hauteur
</p>
</li>
<li>
<p>
<code>(largeurCanevas, hauteurCanevas, nombreColonnes)</code>: idem mais sans titre
</p>
</li>
<li>
<p>
<code>(étiquette, largeurCanevas, hauteurCanevas, nombreLignes, nombreColonnes)</code>: crée un <code>Cadre</code> avec un tableau de <code>nombreDeLignes</code>, <code>nombreDeColonnes</code>
<code>Canevas</code> (avec tous les mêmes dimensions)
</p>
</li>
<li>
<p>
<code>(largeurCanevas, hauteurCanevas, nombreLignes, nombreColonnes)</code>: idem mais sans titre
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe">Méthodes liées aux instances de la classe:</h5>
<div class="ulist"><ul>
<li>
<p>
<code>Canevas canevas()</code> ( &#8658; <code>Cell getCell()</code>) : récupère le <code>Canevas</code> contenu dans un <code>Cadre</code> qui ne contient qu&#8217;une cellule
</p>
</li>
<li>
<p>
<code>Canevas canevas(indexColonne)</code> ( &#8658; <code>Cell getCell(colIndex)</code>) : récupère le <code>Canevas</code>  à l&#8217;index <code>indexColonne</code> contenu dans un <code>Cadre</code> qui  contient un  alignement de
cellules (les index commencent à 0 comme dans les tableaux)
</p>
</li>
<li>
<p>
<code>Canevas canevas(indexLigne, indexColonne)</code> ( &#8658; <code>Cell getCell(lineIndex, colIndex)</code>) : récupère le <code>Canevas</code> aux coordonnées (<code>indexLigne, indexColonne</code>) contenu dans un
<code>Cadre</code> qui contient un  tableau de cellules
</p>
</li>
<li>
<p>
<code>Canevas[] tousLesCanevas()</code> (&#8658; <code>Cell[] cells()</code>): rend un tableau des <code>Canevas</code> contenus dans le <code>Cadre</code>
</p>
</li>
<li>
<p>
<code>siClicSurTous(fermeture)</code> (&#8658; <code>allOnClick(closure)</code>) : applique la méthode <code>siClic</code> (voir
<a href="#siClic">ICI</a>) sur tous les <code>Canevas</code> du <code>Cadre</code>. En général il s&#8217;agit d&#8217;une fermeture avec au moins un argument (le <code>Canevas</code> cliqué lui sera passé).
</p>
</li>
<li>
<p>
<code>ajouterAuNord(composantAWT)</code> et <code>retirerDuNord(composantAWT)</code> (&#8658; <code>addNorth</code> et <code>removeNorth</code>): rajoute (ou enlève) un composant graphique AWT (comme un bouton ou un <code>Label</code>)
sur un bandeau situé en haut (au "Nord") du <code>Cadre</code>. Les mêmes méthodes existent pour un bandeau bas (au "Sud"). <em>a priori</em> voir les méthodes "fabriques" globales (dans <code>Fab</code>):
<code>créerBouton</code> et <code>créerLabel</code> (mais d&#8217;autres composants AWT peuvent être utilisés).
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect3">
<h4 id="canevas">Canevas (&#8658; Cell)</h4>
<div class="paragraph"><p>On ne doit pas utiliser les constructeurs de <code>Canevas</code> (c&#8217;est le <code>Cadre</code> qui les génère).</p></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_2">Méthodes liées aux instances de la classe:</h5>
<div class="ulist"><ul>
<li>
<p>
<code>int ligne()</code> et <code>int colonne()</code> (&#8658; <code>getLinePos</code> et <code>getColPos</code>): donnent les index du <code>Canevas</code> courant dans le <code>Cadre</code> qui les contient.
(utile dans la gestion d'évènement: on sait ainsi quel <code>Canevas</code> est concerné).
</p>
</li>
</ul></div>
<div class="ulist" id="siClic"><div class="title">&#160;</div><ul>
<li>
<p>
<code>VeilleurSouris siClic(fermeture)</code> (&#8658; <code>MouseListener onClick(closure)</code>) :
enregistrement d&#8217;un gestionnaire d'évènement. Cette fonction peut avoir:
</p>
<div class="ulist"><ul>
<li>
<p>
zero argument
</p>
</li>
<li>
<p>
un argument de type <code>Canevas</code> (&#8658; <code>Cell</code>): on saura alors quel est le <code>Canevas</code> concerné par le clic.
</p>
</li>
<li>
<p>
trois arguments: (<code>Canevas, int, int</code>): les deux derniers donneront les coordonnées du clic.
</p>
</li>
</ul></div>
</li>
<li>
<p>
<code>retirerVeilleurSouris(VeilleurSouris)</code> (&#8658; <code>removeMouseListener(MouseListener)</code>) :
retire le code de veille
</p>
</li>
<li>
<p>
<code>VeilleurSelection siSelection(fermeture)</code> (&#8658; <code>scrountch.utils.SelectionListener onSelection(closure)</code>) : enregistre un code qui permet à la souris de sélectionner une zone
dans le <code>Canevas</code> (par glissement). L&#8217;argument de la fonction doit être de type <code>java.awt.geom.Rectangle2D</code> : l'événement donne ainsi les coordonnées de la zone sélectionnée.
<a href="#imageCapture">voir ici ce qu&#8217;on peut faire du rectangle sélectionné</a>
</p>
</li>
<li>
<p>
<code>retirerVeilleurSelection(VeilleurSelection)</code> (&#8658; <code>removeSelectionListener(SelectionListener)</code>): retire le code de veille
</p>
</li>
<li>
<p>
<code>Canevas ajoutGraphique(objetGraphique)</code> ( &#8658; <code>Cell addToGraphics(graphicObject)</code>) : rajoute un <code>ObjetGraphique</code> dans le <code>Canevas</code>. Renvoie le <code>Canevas</code> courant.
Cette méthode force le <code>canevas</code> courant à se repeindre (la méthode spécialisée <code>addNoRepaint(graphicObject)</code> rajoute un élément sans déclencher cette mise à jour du dessin).
</p>
</li>
<li>
<p>
<code>Canevas effacerGraphique(objetGraphique)</code> ( &#8658; <code>removeFromGraphics(graphicObjet)</code>) : retire l&#8217;objet graphique du <code>Canevas</code> courant et le repeint.
(la méthode spécialisée <code>remove</code> ne fait pas cette mise à jour du dessin)
</p>
</li>
<li>
<p>
<code>ajouteListeGraphique(List&lt;ObjetGraphique&gt;)</code> ( &#8658; <code>adAll(List&lt;GraphicObject&gt;</code>) : rajoute tous les objets graphiques passés en argument au <code>Canevas</code>
</p>
</li>
<li>
<p>
<code>List&lt;ObjetGraphique&gt; listeGraphique()</code> ( &#8658;  <code>getList()</code>) : donne la liste de tous les objets graphiques présents dans le <code>Canevas</code>
</p>
</li>
<li>
<p>
<code>effacerTout()</code> ( &#8658; <code>clearGraphics()</code>) : retire tous les objets graphiques du <code>Canevas</code> courant et le repeint ( <code>clear()</code> opére sans repeindre)
</p>
</li>
<li>
<p>
<code>repeindre()</code> ( &#8658; <code>forceRepaint()</code>): force le <code>Canevas</code> courant à se repeindre (important par ex. dans les animations après chaque "mouvement" d&#8217;un objet graphique)
</p>
</li>
<li>
<p>
<code>arrièrePlan(Color couleur)</code> ( &#8658; <code>setBackground(Color)</code>): change la couleur du fond.
</p>
</li>
<li>
<p>
<code>couleurTracé(Color couleur)</code> ( &#8658; <code>setForeground(Color)</code>) : change la couleur  par défaut des tracés (chaque objet graphique peut adopter sa propre couleur).
</p>
</li>
<li>
<p>
<code>setFont(Font)</code> : modifie la police de caractère par défaut
</p>
</li>
</ul></div>
<div class="paragraph"><p>Les bords d&#8217;un <code>Canevas</code> sont des objets <code>GraphicZone</code> (d'épaisseur nulle) utilisés pour la détection des collisions (voir la détection de collisions).</p></div>
</div>
</div>
<div class="sect3">
<h4 id="objetGraphique">ObjetGraphique (&#8658; GraphicObject)</h4>
<div class="paragraph"><p>C&#8217;est une classe abstraite qui mutualise les comportements de <code>ImageGraphique</code>, <code>ChaineGraphique</code> et <code>FormeGraphique</code>; les méthodes décrites ici sont communes
à toutes ces classes (attention toutefois: dans certain cas le comportement de la méthode peut être spécifique à une classe - on dit qu&#8217;il est "spécialisé" -)</p></div>
<div class="sect4">
<h5 id="_méthodes_générales">Méthodes générales:</h5>
<div class="ulist"><ul>
<li>
<p>
<code>int hauteurInitiale()</code> (&#8658; <code>getOriginalHeight()</code>) et <code>int largeurInitiale()</code> (&#8658; <code>getOriginalWidth()</code>) : donne la hauteur et la largeur
de l&#8217;objet graphique. Pourquoi "initiale"? Parce que suite à des déformations ces dimensions peuvent changer suite à des opérations lancées par le code utilisateur.
ATTENTION!: ces valeurs sont inacessibles pour les chaînes de caractères tant que celles-ci n&#8217;ont pas été déployées dans le <code>Canevas</code>.
</p>
<div class="paragraph"><p>De la même manière on peut obtenir la position originale de l&#8217;objet dans le système de coordonnées du <code>Canevas</code> en invoquant <code>getOriginalX()</code> et <code>getOriginalY()</code></p></div>
</li>
</ul></div>
<div class="paragraph"><p>L&#8217;essentiel des méthodes communes concerne les déplacements d&#8217;objets (translation et rotation) et - pour les programmeurs ceintures noires - les déformations (<code>AffineTransform</code>).
Attention: toutes les mesures sont exprimées en valeur <code>double</code>!</p></div>
<div class="ulist"><ul>
<li>
<p>
D&#8217;abord <code>retour()</code> (&#8658; <code>home()</code>): permet de revenir à l'état initial de l&#8217;objet avant toute translation ou rotation
</p>
</li>
<li>
<p>
Les translations sont controlées par deux paramètres: la direction (par défaut horizontal de la gauche vers la droite) et le déplacement dans cette direction (en points graphiques)
</p>
<div class="ulist"><ul>
<li>
<p>
<code>changerDirection(angle)</code> (&#8658; <code>changeDirection(angle)</code>) : la direction du déplacement est changée de <code>angle</code> degrés (dans le sens des aiguiles d&#8217;une montre).
</p>
</li>
<li>
<p>
<code>déplacerDe(points)</code> (&#8658; <code>moveAlong(points)</code>) : déplace l&#8217;objet dans la direction actuelle d&#8217;une distance de <code>points</code> (Attention: la valeur de <code>points</code> s&#8217;exprime en <code>double</code> - aussi
bizarre que ça puisse paraître -). Une valeur négative est possible.
</p>
</li>
</ul></div>
</li>
<li>
<p>
Les rotations sont exécutées après les translations (et les déformations éventuelles). Il y a deux sortes de rotation (exclusives l&#8217;une de l&#8217;autre): les rotations "centrées" (le code essaye de calculer
un "centre" sur l&#8217;objet - ce qui ne donne pas toujours des résultats intuitifs -) et les rotations autour du point d&#8217;ancrage (normallement le coin supérieur gauche).
les angles sont toujours exprimés en degrés (dans le sens des aiguilles d&#8217;une montre) et en <code>double</code>.
</p>
<div class="ulist"><ul>
<li>
<p>
<code>rotationCentrée(angle)</code> (&#8658; <code>centerRotation(angle)</code>) : demande une rotation centrée
</p>
</li>
<li>
<p>
<code>rotationCoin(angle)</code> (&#8658; <code>cornerRotation(angle)</code>) : demande de rotation autour du point d&#8217;ancrage
</p>
</li>
<li>
<p>
<code>annulerRotations()</code> (&#8658; <code>clearRotation()</code>) : annulle les rotations
</p>
</li>
</ul></div>
</li>
<li>
<p>
<code>addTransformation(AffineTransform transformation)</code>: (pour ceinture noires seulement) rajoute une tranksformation à la liste des transformations de l&#8217;objet graphique (permet, par exemple, des déformations). Les transformations sont exécutées après les translations et avant les rotations.
<code>clearTransformations()</code>: annulle cette liste.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect3">
<h4 id="imageGraphique">ImageGraphique (&#8658; GraphicImage)</h4>
<div class="paragraph"><p>Les objets <code>ImageGraphique</code> (&#8658; <code>GraphicImage</code>) sont construits à partir d&#8217;une image gérée par le type <code>Icone</code> (&#8658; <code>scrountch.geom.IconImage</code>).
L&#8217;objet contient une image et des paramètre supplémentaires permettent de gérer la position (x,y) de l&#8217;image dans le <code>Canevas</code> ainsi, éventuellement, que son échelle.</p></div>
<div class="paragraph"><p>On aura donc plusieurs versions de paramètres des diverses fabriques et constructeurs (nota: les coordonnées s&#8217;expriment toujours en <code>double</code>):</p></div>
<div class="ulist"><ul>
<li>
<p>
( <code>icone</code> ou ressource permettant de générer une <code>Icone</code> ) : l&#8217;image sera centrée dans le <code>Canevas</code> est l'échelle par défaut (100%) sera appliquée
</p>
</li>
<li>
<p>
(<code>iconeOuRessource</code>, <code>coordonnéeX</code>, <code>coordonnéeY</code>, <code>échelle</code>) :  l'échelle est un entier qui exprime le pourcentage de réduction (par ex: 50) ou
de grossissement (par ex. 200).
</p>
</li>
<li>
<p>
(<code>iconeOuRessource</code>, <code>coordonnéeX</code>, <code>coordonnéeY</code>) :
</p>
</li>
<li>
<p>
(<code>iconeOuRessource</code>, <code>échelle</code>) :  <code>Icone</code> centrée mis à l'échelle
</p>
</li>
</ul></div>
<div class="paragraph"><p>On peut:</p></div>
<div class="ulist"><ul>
<li>
<p>
créer un  objet <code>Icone</code> et le passer aux fabriques et constructeurs de <code>ImageGraphique</code>
</p>
</li>
<li>
<p>
utiliser des fabriques intégrées de <code>ImageGraphique</code> à partir d&#8217;un nom de fichier ou d&#8217;une U.R.L.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Pour créer un objet <code>Icone</code>:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>Icone iconeDepuisFichier(nomFichier)</code> (&#8658; <code>IconImage createIconImageFromFile(fileName)</code>) : permet de créer une <code>Icone</code> depuis un fichier image
</p>
</li>
<li>
<p>
<code>Icone iconeDepuisURL(nomURL)</code> (&#8658; <code>IconImagecreateIconImageFromURL(URLName)</code>): permet de créer une <code>Icone</code> à partir d&#8217;une ressource (attention: ne fonctionne pas
avec les URLs de type "https").
</p>
</li>
</ul></div>
<div class="paragraph"><p>Fabriques "directes" (dans <code>scrountch.Fab</code>) :</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>ImageGraphique imageDepuisFichier(nomFichier, autres paramètres)</code> (&#8658; <code>createGraphicImageFromFile(fileName, other parameters</code>
</p>
</li>
<li>
<p>
<code>ImageGraphique imageDepuisURL(nomURL, autres paramètres)</code> (&#8658; <code>createGraphicImageFromURL(URLName, other parameters)</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Pour créer des <code>ImageGraphique</code> à partir d&#8217;une <code>Icone</code> on peut utiliser les constructeurs de la classe ou les fabriques <code>créerImageGraphiquec(Icone, autres paramètres)</code>
(&#8658; <code>createGraphicImage(IconImage, other parameters)</code>).</p></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_3">Méthodes liées aux instances de la classe:</h5>
<div class="paragraph"><p>Celles de <code>ObjetGraphique</code> plus:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>changerEchelle(nouvelleEchelle)</code> (&#8658; <code>setScale(newScale)</code>): pour changer l'échelle de l&#8217;image
</p>
</li>
<li>
<p>
<code>setImageHandler( Closure&lt;Image&gt; closure)</code> (niveau ceinture noire): enregistre un code qui prend en paramètre une <code>Image</code> et rend
une <code>Image</code>. En général il s&#8217;agit d&#8217;une transformation des pixels de l&#8217;image (sepia, pixelisation, etc.). L&#8217;image rendue doit être exactement
de même taille que l&#8217;image passée en paramètre. Ce code est invoqué chaque fois que l&#8217;image passée en paramètre doit être transformée (déplacement, rotation, etc.) puis affichée.
Un paramètre <code>null</code> annulle cet enregistrement.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect3">
<h4 id="chaineGraphique">ChaineGraphique (&#8658; GraphicString)</h4>
<div class="paragraph"><p>Une <code>ChaineGraphique</code> utilise:</p></div>
<div class="ulist"><ul>
<li>
<p>
Une chaîne de caractères
</p>
</li>
<li>
<p>
Des coordonnées x, y de positionnement de la chaîne dans le <code>Canevas</code> (si absent la chaîne sera centrée). Ces coordonnées s&#8217;expriment toujours en <code>double</code>
</p>
</li>
<li>
<p>
Une police de caractères: objets de type <code>java.awt.Font</code> (si absent la police du <code>Canevas</code> contenant)
</p>
</li>
<li>
<p>
Une couleur de tracé: objets de type <code>java.awt.Color</code> (si absent  la couleur des tracés du <code>Canevas</code> contenant)
</p>
</li>
<li>
<p>
Eventuellement: une "peinture" de remplissage (<code>java.awt.Paint</code>) et une "forme" de pinceau de tracé (<code>java.awt.Stroke</code>). Dans ce cas la chaîne graphique utilise
un objet très particulier qui obéit à des aspects avancés du dessin. (on ne peut spécifier une forme de pinceau que si on a spécifié une peinture)
</p>
<div class="paragraph"><p>Une utilisation simplifiée de peinture est de passer une instance de <code>Color</code> (les programmeurs avancés pourront ensuite créer des "peintures" sophistiquées
comme des dégradés, etc).</p></div>
<div class="paragraph"><p>Pour les <code>Stroke</code>
<a href="#stroke">voir &#8594; ICI</a></p></div>
</li>
</ul></div>
<div class="paragraph"><p>La génération peut se faire par les constructeurs ou par la méthode "fabrique" de <code>Fab</code>: <code>créerChaineGraphique</code> (&#8658; <code>createGraphicString</code>). Les deux prennent les mêmes arguments.</p></div>
<div class="paragraph"><p>Cas où la chaîne est réalisée par un "dessin" graphique (remplissage, trait de tracé) :</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>(String string, double coorx, double coory, Font font, Color couleur, Paint remplissage, Stroke pinceau)</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Cas où la chaîne est réalisée directement:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>(String string, double coorx, double coory, Font font, Color couleur)</code>
</p>
</li>
<li>
<p>
<code>String string,  double coorx, double coory, Font font)</code>
</p>
</li>
<li>
<p>
<code>(String string, double coorx, double coory)</code>
</p>
</li>
<li>
<p>
<code>(String string)</code>: ici la chaîne est centrée
</p>
</li>
<li>
<p>
<code>(String string, Font font)</code>: ici aussi
</p>
</li>
<li>
<p>
<code>(String string, Color couleur)</code>: ici aussi
</p>
</li>
<li>
<p>
<code>(String string, Font font, Color couleur)</code>: ici également
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_4">Méthodes liées aux instances de la classe:</h5>
<div class="paragraph"><p>Celles de <code>ObjetGraphique</code> plus:</p></div>
<div class="ulist"><ul>
<li>
<p>
Méthodes de calcul des dimensions de la chaîne avant toute transformation (nécessitent un <code>Canevas</code> de positionnement). (méthodes de niveau "ceinture noire").
<code>getStdHeight(Cell curCell), getStdWidth(Cell curCell),getStdAscent(Cell curCell), getStdDescent(Cell curCell)</code>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect3">
<h4 id="formeGraphique">FormeGraphique (&#8658; GraphicShape)</h4>
<div class="paragraph"><p>Les objets <code>FormeGraphique</code> (&#8658; <code>GraphicShape</code>) gèrent une "forme": un objet géométrique conforme au contrat de type <code>Forme</code> (&#8658; <code>java.awt.Shape</code>).
Ils utilisent:</p></div>
<div class="ulist"><ul>
<li>
<p>
Une <code>Forme</code> (&#8658; <code>java.awt.Shape</code>)
</p>
</li>
<li>
<p>
Des coordonnées x, y de positionnement de la forme dans le <code>Canevas</code> (si absent la forme sera centrée). Ces coordonnées s&#8217;expriment toujours en <code>double</code>.
Attention certaines <code>Forme</code> définissent en interne leurs propres coordonnées d&#8217;ancrage: dans ce cas ces coordonnées s&#8217;ajouterons aux coordonnées x, y.
Le centrage est particulièrement délicat voir
<a href="#centrage">&#8594;</a>.
</p>
</li>
<li>
<p>
Une couleur de tracé: objets de type <code>java.awt.Color</code> (si absent  la couleur des tracés du <code>Canevas</code> contenant)
</p>
</li>
<li>
<p>
Une "peinture" de remplissage (<code>java.awt.Paint</code>) (si absent pas de remplissage). Attention! Si la forme n&#8217;est pas "fermée" le remplissage s&#8217;operera de manière incontrolée.
</p>
</li>
<li>
<p>
Une "forme" de pinceau de tracé (<code>java.awt.Stroke</code>) (si absent trait par défaut): peut être un trait épais, avec des pointillés, etc&#8230;.
Pour une utilisation simplifiée voir la fabrique <code>créerTrait</code> (&#8658; <code>createStroke</code>); on peut passer divers paramètres mais le plus simple est de passer un entier
qui donne l'épaisseur du trait en nombre de points (sinon voir les paramètres du constructeur de <code>java.awt.BasicStroke</code> ou
des <code>Stroke</code> plus sophistiqués - pour programmeurs ceintures noires seulement -)
</p>
</li>
</ul></div>
<div class="paragraph" id="stroke"><p>Il existes de nombreuses façons de générer des <code>Forme</code>s: on peut utiliser des constructeurs de formes du package <code>java.awt.geom</code> mais aussi les "fabriques" de <code>Fab</code>:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>Forme créerLigne(double débutX, double débutY, double finX, double finY)   </code> (&#8658; <code>createLine(double x1, double y1, double x2, double y2)</code>).
Existe également en version simplifiée avec début en (0,0) et juste deux coordonnées de fin de ligne.
</p>
</li>
<li>
<p>
<code>Forme créerRectangle( double x, double y, double largeur, double hauteur) </code> (&#8658; <code>createRectangle( double x, double y, double width, double height)</code>).
Existe également en version simplifiée avec ancrage en (0,0) et juste deux paramètres pour la largeur et la hauteur.
</p>
</li>
<li>
<p>
<code>Forme créerEllipse(double x, double y, double largeur, double hauteur)</code> (&#8658; <code>createEllipse( double x, double y, double width, double height) </code>)
Les coordonnées (x,y) sont celles du rectangle englobant (pour faire un cercle c&#8217;est facile: même hauteur et largeur!).
Existe également en version simplifiée avec ancrage en (0,0) et juste deux paramètres pour la largeur et la hauteur.
</p>
</li>
<li>
<p>
<code>Forme créerPolygone(int[] xs, int[] ys) </code> (&#8658; <code>createPolygonint[] xs, int[] ys) </code>): ici , exceptionnellement, on utilise des coordonnées avec des <code>int</code>.
chaque élément du tableau des X doit correspondre à l'élément de même index dans le tableau des y (c&#8217;est un peu compliqué - cela vient d&#8217;un code historique - et pour cette raison
nous vous conseillons plutot d&#8217;utiliser une <code>Tortue</code> pour réaliser un polygone).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Voir aussi
<a href="#turtle">les tortues</a>
et
<a href="#curves">les courbes</a></p></div>
<div class="paragraph"><p>Pour créer des <code>FormeGraphique</code> on peut:</p></div>
<div class="ulist"><ul>
<li>
<p>
Utiliser les constructeurs de la classe ou la méthode fabrique <code>créerFormeGraphique</code> (&#8658; <code>createGraphicShape</code>): les deux utilisent les mêmes paramètres.
Attention: toutes les fois que les coordonnées X ou Y ne sont pas fixées la figure se cadre par rapport au centre  &#8230; mais si
les coordonnées propres à la figure ne sont pas zero l&#8217;effet escompté n&#8217;est peut-être pas celui que vous attendez
voir
<a href="#centrage">&#8594;</a>.
</p>
<div class="ulist"><ul>
<li>
<p>
<code>( Forme forme, double x, double y ,Color couleur, Paint remplissage, Stroke pinceau)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, double x, double y, Color couleur, Paint remplissage)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, double x, double y ,Color couleur)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, double x, double y ,Stroke pinceau)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, double x, double y)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, Color couleur, Paint remplissage,Stroke pinceau)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, Color couleur, Paint remplissage)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, Color couleur)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme, Stroke pinceau)</code>
</p>
</li>
<li>
<p>
<code>( Forme forme)</code>
</p>
</li>
</ul></div>
</li>
<li>
<p>
Faire appel à une fabrique spéciale qui centre la forme: <code>formeGraphiqueCentrée</code> (&#8658; <code>centeredGraphicShape</code>)
</p>
<div class="ulist"><ul>
<li>
<p>
<code>(Forme forme, Color couleur, Paint remplissage, Stroke pinceau)</code>
</p>
</li>
<li>
<p>
<code>(Forme forme, Color couleur, Paint remplissage)</code>
</p>
</li>
<li>
<p>
<code>(Forme forme, Color couleur,  Stroke pinceau)</code>
</p>
</li>
<li>
<p>
<code>(Forme forme, Color couleur)</code>
</p>
</li>
<li>
<p>
<code>(Forme forme,  Stroke pinceau)</code>
</p>
</li>
<li>
<p>
++(Forme forme)
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="shape">Extensions des codes de Forme (&#8658; java.awt.Shape)</h4>
<div class="paragraph"><p><code>Forme</code> (&#8658; <code>Shape</code>) est un code standard de <code>java</code>; toutefois Scrountch a rajouté
dynamiquement des méthodes à ce code:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>double hauteur()</code> (&#8658; <code>getHeight()</code>+): donne la hauteur du rectangle englobant au mieux la forme.
</p>
</li>
<li>
<p>
<code>double largeur()</code> (&#8658; <code>getWidth()</code>+): donne la largeur du rectangle englobant au mieux la forme.
</p>
</li>
<li>
<p>
<code>double plusGrandeDim()</code> (&#8658; <code>maxDim()</code>+): donne la plus grande valeur en la hauteur et la largeur du rectangle englobant au mieux la forme.
</p>
</li>
<li>
<p>
<code>double hypot()</code> (&#8658; <code>hypot()</code>+): donne l&#8217;hypothénuse du rectangle englobant au mieux la forme.
</p>
</li>
<li>
<p>
<code>Radial2D radialInfo()</code>: l&#8217;objet obtenu permet de donner une approximation utilisable pour réaliser des rotations de la forme: coordonnées d&#8217;un centre  et rayon.
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="turtle">Tortue (&#8658; Turtle)</h4>
<div class="paragraph"><p>Une <code>Tortue</code> est un code qui permet de réaliser une <code>Forme</code> par "cheminement" (<code>Path2D</code>).
Une fois créée et positionnée la tortue peut changer de direction et avancer de N points.
(exceptionnellement ici les valeurs des coordonnées et des mouvements sont exprimés avec des <code>int</code>; les valeurs d&#8217;angles restant en <code>double</code>).</p></div>
<div class="paragraph"><p>Pour créer une <code>Tortue</code> on peut faire appel à son constructeur ou à la fabrique <code>créerTortue</code> (&#8658; <code>createTurtle</code>) les paramètres possibles sont:</p></div>
<div class="ulist"><ul>
<li>
<p>
(pas de paramètre): La tortue part de (0,0) et la direction est, horizontalement, de la gauche vers la droite
</p>
</li>
<li>
<p>
<code>(int x, int y)</code>: La tortue part de (x,y) et la direction est, horizontalement, de la gauche vers la droite
</p>
</li>
<li>
<p>
<code>(int x, int y, double angle)</code>: La tortue part de (x,y) et la direction fait un angle (en degrés) à partir de l&#8217;horizontale dans le sens des aiguilles d&#8217;une montre.
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_5">Méthodes liées aux instances de la classe:</h5>
<div class="paragraph"><p>Elles permettent de tracer la figure (faire attention de faire une figure fermée si on veut un remplissage dans la
<code>FormeGraphique</code> qui utilise la tortue).</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>avance(int nbPoints)</code> (&#8658; <code>forward</code>)
</p>
</li>
<li>
<p>
<code>tourneDroite(double angle)</code> (&#8658; <code>turnRight</code>): change la direction d&#8217;avancement de l&#8217;angle en degré (dans le sens des aiguilles d&#8217;une montre)
</p>
</li>
<li>
<p>
<code>tourneGauche(double angle)</code> (&#8658; <code>turnLeft</code>) : change la direction d&#8217;avancement vers la gauche
</p>
</li>
<li>
<p>
<code>sauteEn(int x, int y)</code> (&#8658; <code>jumpTo</code>) : change la position courante sans qu&#8217;un tracé soit réalisé.
</p>
</li>
<li>
<p>
<code>java.awt.geom.Point2D pointCourant()</code> (&#8658; <code>getCurrentPoint</code>) : quelles sont les coordonnées actuelles? (sur un objet <code>Point2D</code> les méthodes <code>getX()</code> et <code>getY()</code> rendent
une valeur <code>double</code>)
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="curves">Courbes</h3>
<div class="paragraph"><p>TODO</p></div>
<div class="sect3">
<h4 id="SButton">Bouton (&#8658; SButton)</h4>
<div class="paragraph"><p>Pour créer un <code>Bouton</code> le code constructeur (ou la méthode "fabrique" <code>CréerBouton</code>) exige deux paramètres:</p></div>
<div class="ulist"><ul>
<li>
<p>
un identifiant qui permettra de savoir quel bouton a été cliqué dans les codes de gestion d'évènement
</p>
</li>
<li>
<p>
le label qui sera affiché sur le bouton
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_6">Méthodes liées aux instances de la classe:</h5>
<div class="paragraph"><p>Les méthodes héritées de la classe <code>java.awt.Button</code> plus:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code> String getRef()</code>: renvoie l&#8217;identification du Bouton
</p>
</li>
<li>
<p>
<code>VeilleurAction siClic(Fermeture code)</code> (&#8658; <code>ActionListener onCLick(Closure code)</code>) : permet d&#8217;enregistrer un code qui réagira
si on clique sur le bouton. Ce peut être un code sans paramètre (si on connait le bouton qui va réagir) ou avec un
paramètre de type <code>String</code> (qui donnera l&#8217;identifiant du bouton cliqué). (pour supprimer l&#8217;action voir la méthode
<code>removeActionListener</code> de la classe <code>Button</code>)
</p>
</li>
<li>
<p>
<code>VeilleurAction siClic(Runnable code)</code> (&#8658; <code>ActionListener onCLick(Runnable code)</code>) : permet d&#8217;enregistrer un code qui réagira
si on clique sur le bouton. Ici il s&#8217;agit d&#8217;un code de réaction sans paramètre transmis.
</p>
</li>
<li>
<p>
<code>VeilleurAction siClic(Consumer&lt;String&gt; code)</code> (&#8658; <code>ActionListener onCLick(Consumer&lt;String&gt; code)</code>) : permet d&#8217;enregistrer un code qui réagira
si on clique sur le bouton. Ici l&#8217;identifiant du bouton sera transmis au code.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_traitement_d_8217_images">Traitement d&#8217;images</h3>
<div class="paragraph"><p>Il s&#8217;agit d&#8217;aspects un peu plus avancés de la programmation avec <code>scrountch</code>.
Les méthodes n&#8217;ont pas été traduites et gardent, a priori, leur nom en Anglais (mais cela peut changer si nécessaire).</p></div>
<div class="paragraph"><p>Les classes fondamentales sont <code>Icone</code> (<code>scrountch.geom.IconImage</code>) et <code>java.awt.image.BufferedImage</code> (ainsi que <code>java.awt.Image</code>).</p></div>
<div class="paragraph"><p>Il faut garder à l&#8217;esprit que les images utilisent beaucoup de ressources. On a donc la possibilité de les gérer dans un cache mémoire
qui conserve les dernières images utilisées. Le code de ce cache est <code>scrounth.utils.Cache</code> et beaucoup d&#8217;utilitaires
vous conseillent d&#8217;utiliser un mot-clef  qui permet de stocker et de retrouver une image dans le cache.</p></div>
<div class="paragraph"><p>On peut créer ses propres caches mais il y en a un par défaut dans <code>scrountch.geom.ImageUtils.cache</code> qui associe
des objet de type <code>java.awt.Image</code> à un <code>String</code> (la "clef" de l&#8217;image).</p></div>
<div class="sect3">
<h4 id="_le_cache">Le Cache</h4>
<div class="paragraph"><p>C&#8217;est un outil sophistiqué qui opère à double détente:</p></div>
<div class="paragraph"><p>Il stocke des données dans une table de hachage &#8230; de taille limitée: quand cette taille est atteinte la plus vielle donnée stockée
est passée à une autre table qui stocke provisoirement des données &#8230; jusqu'à ce que les besoins en mémoire font
que cette donnée "périmée" soit éliminée. Donc on n&#8217;est pas sûr de retrouver dans le cache une donnée qu&#8217;on y a stockée (si elle est périmée
elle a disparu et donc il faudra la reconstituer)</p></div>
<div class="paragraph"><p>Le <code>Cache</code> par défaut (<code>ImageUtils.cache</code>) associe un mot-clef à un objet <code>Image</code> mais on peut, si besoin est créer d&#8217;autres objets <code>Cache</code>.</p></div>
<div class="paragraph"><p>La classe est paramétrée <code>Cache&lt;K,X&gt;</code> ou <code>K</code> est le type de la clef (généralement un <code>String</code>) et <code>X</code> le type de la valeur stockée.</p></div>
<div class="paragraph"><p>Le constructeur est <code>Cache (int tailleBase, int tailleMax)</code> : ici <code>tailleBase</code> est la taille initiale de la table
de stockage et <code>tailleMax</code> est le nombre maximum d'éléments que l&#8217;on peut stocker (au délà les éléments sont "poussés" dans
la table des objets en attente de récupération par le gestionnaire de mémoire).</p></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_7">Méthodes liées aux instances de la classe:</h5>
<div class="ulist"><ul>
<li>
<p>
<code>void put(K clef, X arg)</code>: demande de stockage d&#8217;un objet avec une clef
</p>
</li>
<li>
<p>
<code>boolean containsKey(K clef)</code>: dis si l&#8217;objet répéré par cette clef est encore dans le cache.
</p>
</li>
<li>
<p>
<code>X get(K clef)</code>: rend l&#8217;objet répéré par cette clef s&#8217;il est encore dans le cache. Dans le cas contraire rend <code>null</code>
(pour des raisons de performances éviter de faire d&#8217;abord <code>containsKey</code> puis <code>get</code>: il suffit de tester si <code>get</code> rend <code>null</code>)
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect3">
<h4 id="_icone_8658_iconimage">Icone (&#8658; IconImage)</h4>
<div class="paragraph"><p>En fait il s&#8217;agit d&#8217;une sous-classe de <code>javax.swing.ImageIcon</code>. qui permet de charger des images
sans utiliser de tâche de fond (c&#8217;est plus couteux en temps d&#8217;exécution mais ça simplifie la programmation).</p></div>
<div class="paragraph"><p>Les constucteurs peuvent prendre:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>(String nomfichierImage)</code>
</p>
</li>
<li>
<p>
<code>(URL URLimage)</code> (ne pas utiliser le protocole <code>https</code>)
</p>
</li>
<li>
<p>
<code>(BufferedImage imageEnBuffer)</code>
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_8">Méthodes liées aux instances de la classe:</h5>
<div class="paragraph"><p>En fait celles héritées de la classe <code>javax.swing.ImageIcon</code> et, en particulier, <code>java.awt.Image getImage()</code></p></div>
</div>
</div>
<div class="sect3">
<h4 id="_opérations_liées_aux_images">opérations liées aux  images</h4>
<div class="paragraph"><p>Les méthodes sont des méthodes générales ("statiques") de la classe <code>scrountch.geom.ImageUtils</code></p></div>
<div class="ulist" id="imageCapture"><ul>
<li>
<p>
<code>BufferedImage imageCapture(Cell comp, Rectangle2D rect)</code> (et <code>BufferedImage imageCapture(Cell comp, Rectangle rect)</code>): permettent
de transformer en une image un rectangle sélectionné dans un <code>Canevas</code> (voir méthode <code>siSelection</code> de <code>Canevas</code> &#8658; <code>Cell</code>)
</p>
</li>
<li>
<p>
<code>BufferedImage toBufferedImage(ImageIcon icon)</code> extrait un objet <code>BufferedImage</code> d&#8217;une <code>Icone</code> (<code>scrountch.geom.IconImage</code> ou
<code>javax.swing.ImageIcon</code>)
</p>
</li>
<li>
<p>
<code>BufferedImage toBufferedImg(java.awt.Image img)</code>
</p>
</li>
<li>
<p>
<code>Area getNonTransparentArea(java.awt.Image colorImage)</code>: (très intéressant) permet d&#8217;obtenir une surface de contour
d&#8217;une image qui contient des parties transparentes (attention peut donner des résutlats inattendus si l&#8217;image n&#8217;a pas de contours entourant
une surface).
</p>
</li>
<li>
<p>
<code>Shape shapeFromString(double coorX, double coorY, String string, Font font, Graphics2D context)</code>: permet d&#8217;obtenir une <code>Forme</code> (<code>Shape</code>)
à partir d&#8217;un chaîne située en <code>coorX</code>, <code>coorY</code> dans un contexte graphique (par ex. celui d&#8217;un <code>Canevas</code>).
</p>
</li>
<li>
<p>
<code>Image applyFilter(Image colorImage, String key, ImageFilter filter)</code>: crée une image en appliquant un filtre. Si cette image existe déjà
dans le cache avec cette clef elle est rendue directement: les filtres sont des opérations couteuses et si l&#8217;opération
a déjà été enregistrée on gagne du temps (et de l&#8217;espace). La même méthode existe sans clef d&#8217;enregistrement.
</p>
</li>
<li>
<p>
<code>Image grey(Image colorImage, String key)</code>: applique un filtre rendant une image en niveaux de gris.
la même méthode existe sans clef d&#8217;enregistrement.
</p>
</li>
<li>
<p>
<code>Image sepia(Image colorImage, String key)</code>: applique un filtre sepia.
la même méthode existe sans clef d&#8217;enregistrement.
</p>
</li>
<li>
<p>
<code>BufferedImage pixelate(Image colorImage, String key, int pixSize)</code>: transforme une image en la brouillant par des petits carrés de couleur.
<code>pixSize</code> est la taille de ces carrés.
la même méthode existe sans clef d&#8217;enregistrement.
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_images_composites">images composites</h4>
<div class="paragraph"><p>Voir la classe <code>scrountch.geom.CompositeImage</code> (sous classe de <code>Icone</code> &#8658; <code>IconImage</code>)
qui permet de construire des images à partir d'éléments divers (superpositions, échancrures, etc.)</p></div>
<div class="paragraph"><p>Le constructeur:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>CompositeImage(BufferedImage bufr)</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Les "fabriques" (méthodes statiques de la classe):</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>CompositeImage factFromIcon(ImageIcon icon)</code>: créée à partir d&#8217;une <code>ImageIcon</code>
</p>
</li>
<li>
<p>
<code>CompositeImage factory(int width, int height, Color color)</code>: créée sous la forme d&#8217;un rectangle d&#8217;une couleur donné
(plus largeur et hauteur).
</p>
</li>
<li>
<p>
<code>CompositeImage defaultCover(Cell cell)</code>: crée un rectangle comme précédemment mais à partir d&#8217;un <code>Canevas</code> (&#8658; +Cell).
permet ensuite de mettre des zones en transparence.
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_méthodes_liées_aux_instances_de_la_classe_9">Méthodes liées aux instances de la classe:</h5>
<div class="ulist"><ul>
<li>
<p>
<code>changeZoneColor(int x, int y, int width, int height, Color color)</code>:
change la couleur d&#8217;un partie de l&#8217;image
</p>
</li>
<li>
<p>
<code>superposeIcon(int x, int y, ImageIcon icon)</code>;
<code>superposeIcon(Rectangle2D rect, ImageIcon icon)</code> :
et <code>superposeIcon(int x, int y, int width, int height, ImageIcon icon)</code>:
superpose une image à l&#8217;image courante
</p>
</li>
<li>
<p>
<code>superposeBuffer(Rectangle2D rect, BufferedImage bufr)</code> et <code>superposeBuffer(int x, int y, int width, int height, BufferedImage bufr)</code>:
superpose une image bufferisée à l&#8217;image courante
</p>
</li>
<li>
<p>
<code>superposeShape(double x, double y, Shape shape, Color color, Paint fillPaint, Stroke stroke)</code>:
et <code>superposeShape(double x, double y, Shape shape, Color color, Paint fillPaint)</code> :
Dessine une <code>Forme</code> (&#8658; <code>Shape</code>) sur l&#8217;image courante.
</p>
</li>
<li>
<p>
<code>superposeText(double x, double y, String text, Font font, Color color, Paint fillPaint, Stroke stroke)</code>
dessine un texte sur l&#8217;image courante.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_corrigés">Corrigés</h3>
<div class="sidebarblock" id="exoFunc">
<div class="content">
<div class="title">fonction simple</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> Cadre cadreCarré(String chaine) {
    int taille = Integer.parseInt(chaine)
    Cadre res = créerCadre(chaine +" x "+ chaine, taille, taille)
    <strong>return</strong> res
}

String saisie = readln("donner dimension cadre")
cadreCarré(saisie)</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoImage1">
<div class="content">
<div class="title">fonction simple, Image Graphique</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> afficherImage(String nomURL){
    ImageGraphique image = imageDepuisURL(nomURL)
    Cadre cadre = créerCadre(nomURL, image.largeurInitiale(), image.hauteurInitiale())
    Canevas fondDessin = cadre.canevas()
    fondDessin.ajoutGraphique(image)
}

String nom = readln("donnez l'URL de l'image")
afficherImage(nom)</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoPolygone">
<div class="content">
<div class="title">tableau, forme graphique</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> afficherPolygone(int[] xs, int[] ys) {
    Cadre cadre = créerCadre("polygone", 300,300)
    Canevas canevas = cadre.canevas()
    FormeGraphique forme = créerPolygoneGraphique(xs, ys)
    canevas.ajoutGraphique(forme)
}

int[] lesX = [100,200,200, 100]
int[] lesY = [100,100,200, 200]
afficherPolygone(lesX, lesY)</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoIfGraf">
<div class="content">
<div class="title">choix, echelle image</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> adapterImage(String nomURL){
    int hauteurCadre = 300
    int largeurCadre = 300
    ImageGraphique image = imageDepuisURL(nomURL)
    Cadre cadre = créerCadre(nomURL,largeurCadre, hauteurCadre)
     int hauteurImage = image.hauteurInitiale()
    int largeurImage = image.largeurInitiale()
    double echelleHauteur = (hauteurCadre * 100D)  / hauteurImage
    double echelleLargeur = (largeurCadre * 100D) / largeurImage
    int plusPetitRapport = echelleLargeur
    <strong>if</strong>(echelleHauteur &lt; echelleLargeur) {
      plusPetitRapport = echelleHauteur
    }
    <strong>if</strong>(plusPetitRapport &lt; 100) {
      image.changerEchelle(plusPetitRapport)
    }
    Canevas fondDessin = cadre.canevas()
    fondDessin.ajoutGraphique(image)
}

String nom = readln("donnez l'URL de l'image")
adapterImage(nom)</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoLoopGraf">
<div class="content">
<div class="title">boucles, animation, échelle d&#8217;image</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> animation(String url) {
    ImageGraphique img = imageDepuisURL(url)
    Cadre cadre = créerCadre(url, img.largeurInitiale(), img.hauteurInitiale())
    Canevas canevas = cadre.canevas()
    canevas.ajoutGraphique(img)
    int échelle = 100
    int compteur = 0
    <strong>while</strong> (compteur &lt; 20) {
        <strong>while</strong> (échelle &gt;= 50) {
            img.changerEchelle(échelle)
            pause(150)
            canevas.repeindre();
            échelle = échelle - 5
        }
        <strong>while</strong> (échelle &lt;= 100) {
            img.changerEchelle(échelle)
            pause(150)
            canevas.repeindre()
            échelle = échelle + 5
        }
        compteur = compteur + 1
    }
}

animation("file:heart.png")</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="polyTortue">
<div class="content">
<div class="title">boucles, utilisation tortue</div>
<div class="listingblock">
<div class="content">
<pre><code><i>//un fonction pour calculer l'angle interne d'un poluygone régulier</i>
<strong>def</strong> double angleInternePolygone(int nbCotés) {
 <strong>return</strong> ((nbCotés -2) * 180D)/ nbCotés
}

<i>//taille du coté d'un polygone régulier en focntion du rayon</i>
<strong>def</strong> int tailleCoté(int rayon, int nbCotés) {
   <strong>return</strong> 2 * (rayon * Math.sin(Math.PI/nbCotés))
}

<strong>def</strong> polygoneParTortue(int rayon, int nbCotés) {
  int coté = tailleCoté(rayon, nbCotés)
  double angleRotation =  180 - angleInternePolygone(nbCotés)
  Tortue tortue = créerTortue()
  int ix = 0
  <strong>while</strong>(ix &lt; nbCotés) {
      tortue.avance(coté)
      tortue.tourneDroite(angleRotation)
      ix = ix +1
  }
  <i>//FormeGraphique graphe = créerFormeGraphique(tortue, recentrer(), recentrer())</i>
  FormeGraphique graphe = formeGraphiqueCentrée(tortue)
  int dim = tortue.maxDim() + 5
  Cadre cadre = créerCadre(dim, dim)
  Canevas dessin = cadre.canevas()
  dessin.ajoutGraphique(graphe)
 }

 polygoneParTortue(300,7)</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoTranslationGraf">
<div class="content">
<div class="title">boucles, animation, translation</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> marche(String imagefond, String gif) {
    ImageGraphique fond = imageDepuisFichier(imagefond)
    int largeurFond = fond.largeurInitiale() ;
    int hauteurFond = fond.hauteurInitiale() ;
    Icone marcheur = iconeDepuisFichier(gif)
    int largeurMarcheur = marcheur.largeur()
    int hauteurMarcheur = marcheur.hauteur()
    int posInitialeX = -largeurMarcheur
    int posInitialeY = hauteurFond - hauteurMarcheur
    ImageGraphique marcheurGraf = créerImageGraphique(marcheur, posInitialeX, posInitialeY)
    Cadre cadre = créerCadre(largeurFond, hauteurFond)
    Canevas dessin = cadre.canevas()
    dessin.ajoutGraphique(fond)
    dessin.ajoutGraphique(marcheurGraf)
    <strong>while</strong>(true) {
        marcheurGraf.retour()
        int posX = posInitialeX
        <strong>while</strong>(posX &lt; largeurFond) {
            pause(150)
            marcheurGraf.translation(2,0)
            posX = posX +2
            dessin.repeindre()
        }
    }

}

marche("marguerites.png", "dinosaurs.gif")</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoRotation">
<div class="content">
<div class="title">Exercice: boucles, animation, rotations</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong> grandeRoue(int pas, String gif) {
    Icone marcheur = iconeDepuisFichier(gif)
    int largeurMarcheur = marcheur.largeur()
    int hauteurMarcheur = marcheur.hauteur()
    int rayon = hauteurMarcheur
    int dimCadre = (rayon*2 ) + (hauteurMarcheur)
    Cadre cadre = créerCadre(dimCadre, dimCadre)
    int posInitialeX = (dimCadre /2) - (largeurMarcheur /2 )
     int posInitialeY =  dimCadre - hauteurMarcheur
    ImageGraphique marcheurGraf = créerImageGraphique(marcheur, posInitialeX, posInitialeY)
    Canevas dessin = cadre.canevas()
    dessin.ajoutGraphique(marcheurGraf)
    int transX = 0 ;
    int transY = 0
    int angle =  pas
    <strong>while</strong>(true) {
        pause(150)
        transX =  rayon * Math.sin(Math.toRadians(angle))
        transY = -rayon +(rayon * Math.cos(Math.toRadians(angle)))
        marcheurGraf.reinitTranslation(transX, transY)
        marcheurGraf.rotationCentrée(-pas)
        dessin.repeindre()
        angle += pas
    }

}

grandeRoue(5, "sprite_marcheur.gif")</code></pre>
</div></div>
</div></div>
<div class="sidebarblock" id="exoEvent">
<div class="content">
<div class="title">Exercice: fermeture, gestion événements</div>
<div class="listingblock">
<div class="content">
<pre><code><strong>def</strong>  créerDamier(int lignes, colonnes) {
    ImageGraphique pion = imageDepuisFichier("draught1.jpg",20)
    int dim = Math.max(pion.hauteurInitiale(), pion.largeurInitiale())
    Cadre cadre = créerCadre("jeu",dim,dim, lignes, colonnes)
    <i>// on notera qu'il n'y a pas vraiment "fermeture"</i>
    <i>// cette fonction anonyme est autonome</i>
    Fermeture fermeture = {
        Canevas canevas, int x, int y -&gt;
            canevas.ajoutGraphique(pion)
    }
    cadre.siClicSurTous(fermeture)
}

créerDamier(5,5)</code></pre>
</div></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_eléments_de_programmation">Eléments de programmation</h3>
<div class="paragraph"><p>A FAIRE (manuel pour intervenir dans les codes. Priorité: les ressources d&#8217;internationalisation)</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Dernière mise à jour 2017-02-22 17:16:16 CET
</div>
</div>
</body>
</html>
